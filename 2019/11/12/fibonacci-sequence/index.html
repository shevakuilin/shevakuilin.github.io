<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>斐波那契数列 | 跃迁引擎</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="用「动态规划」 「模拟」的思想，解决斐波那契数列，文中题目出自 LINE 的面试笔试算法题，难度中等偏上。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="斐波那契数列 | 跃迁引擎">
    <meta name="twitter:description" content="用「动态规划」 「模拟」的思想，解决斐波那契数列，文中题目出自 LINE 的面试笔试算法题，难度中等偏上。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="斐波那契数列 | 跃迁引擎">
    <meta property="og:description" content="用「动态规划」 「模拟」的思想，解决斐波那契数列，文中题目出自 LINE 的面试笔试算法题，难度中等偏上。">

    
    <meta name="author" content="ShevaKuilin">
    
    
<link rel="stylesheet" href="/css/vno.css">

    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">


    
    <link rel="icon" href="/images/favicon.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://shevakuilin.com/2019/11/12/fibonacci-sequence/"/>

                 
</head>

<body class="home-template no-js">
    
<script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>

    
<script src="/js/main.js"></script>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 跃迁引擎 的主页"><img src="/images/avatar.jpeg" width="80" alt="跃迁引擎 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 跃迁引擎">跃迁引擎</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">空気を読んだ雨降らないでよ</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文章列表</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/shevakuilin" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-11-12T12:28:20.000Z" class="post-list__meta--date date">2019-11-12</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="-none-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a>, <a class="-none-link" href="/tags/%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0/" rel="tag">大整数相加</a>, <a class="-none-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a>, <a class="-none-link" href="/tags/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB/" rel="tag">状态转移</a>, <a class="-none-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a>
 </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">斐波那契数列</h1>
  </header>

  <section class="post">
    <p>用「动态规划」 「模拟」的思想，解决斐波那契数列，文中题目出自 LINE 的面试笔试算法题，难度中等偏上。<a id="more"></a></p>
<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Where <code>n</code> is a positive integer, the function <code>f(n)</code> satisfies the follow.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">0</span>) = <span class="number">0</span> </span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">f(n) = f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Please create a program to find <code>f(n)</code>.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>Muti datas input until <code>EOF</code>. In every line, input a positive integer <code>n</code>. (1 &lt;= <code>n</code> &lt;= 200)</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Please output the result for <code>f(n)</code>.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2"></a>Sample Input 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2"></a>Sample Output 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure>

<p>此题目是 LINE 在 2018 年社招移动端岗位放出的笔试题，其中有多道，此道题目是其中的一道。LINE 的考察方式是在白纸上写代码。</p>
<p>另外这题还有一个第二问，请求出 <code>fib(8181)</code> 的答案是多少？</p>
<h2 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h2><p>拿到题目的第一件事，当然就是审题了。</p>
<p>乍一看题目很容易就陷入一种这题很简单的误区里，斐波那契数列，一个学校老师只要讲递归就一定会拿出来的例子，快被举烂了，岂不简单？</p>
<p>非也，实际上这是 LINE 的一道难度中等偏上的算法题，如果你大意了，洋洋洒洒写上你的解题答案，你就真的只能被 Out 了。</p>
<p>为什么这么说呢，我们来看回顾一下这道题目的要求：</p>
<ol>
<li>多组数据输入，直到 <code>EOF</code>。<code>EOF</code>是一个计算机术语，为<code>End Of File</code>的缩写，在操作系统中表示资料源无更多的资料可读取，也就是说你需要允许程序一直输入，直到再没有任何输入为止。</li>
<li><code>n</code>的范围是 [1, 200] 的闭区间，也就是最大允许可以输入 n = 200，这仅仅是第一问，而第二问更是变态的要求你打印出 n = 8181 的结果，是不是感受到了满满的恶意？[手动滑稽]</li>
<li>这是一道白板算法，什么意思呢，也就是说，你不能像 leetcode 的刷题习惯那样给出解法就完了，你需要写出一道完整的可执行的程序出来。</li>
</ol>
<p>怎么样，在仔细审题之后，是不是发现这道题里充斥着不少陷阱? 其实还是自己太年轻。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>下面我们来逐步分析这道题，来看看如何化解它。</p>
<p>当你看见这道题，第一反应肯定是递归，标准教案嘛。那好，我们就先尝试以递归算法来暴力的破解它：</p>
<p>首先，斐波那契数列遵循这样的规律：<code>1、1、2、3、5、8、13、21、34...</code>，也就是说，前两个数相加的结果等于第三个数。</p>
<p>根据题目给出的<code>f(0) = 0</code>, <code>f(1) = 1</code>，我们很容易就能推出，<code>f(2) = 1</code>，因为 0 + 1 = 1 嘛，所以斐波那契的通项公式为：<code>f(n) = f(n - 1) + f(n - 2)</code>，题目也已经在开头提供了该公式，那么用暴力递归的解法就是：</p>
<p>ps: 下文的代码都以 <code>C++</code> 来演示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去简洁易懂，嗯，也许你还会觉得很完美，这道题 so easy 嘛。</p>
<p>那么问题来了，尝试画一下 <code>n = 20</code> 的递归树，请开始你的表演 👏:</p>
<p><img src="https://github.com/shevakuilin/GhostPostsImages/raw/master/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.png" alt="递归树"></p>
<p>在这个递归树下，想要计算原问题 f(20)，你就得先计算出子问题 f(19) 和 f(18)，要计算 f(19)，你就得计算出 f(18) 和 f(17)，直到计算到 f(2) 和 f(1) 直接返回结果，这是树的左半边，然后你还需要用相同的方式计算出右半边的 f(18)，以此类推。</p>
<p>而递归算法的时间复杂度等于<code>子问题个数乘以解决一个子问题需要的时间</code>，可想而知，这种暴力递归解法是十分低效的。</p>
<p>在这种算法中，<code>子问题个数</code> = 递归树当中所有节点的总数，本例中 f(20) 的二叉树的节点总数为指数级别，子问题个数为 <code>O(2^n)</code>。</p>
<p>由于只有一个 <code>f(n - 1) + f(n - 2)</code> 加法操作，所以解决<code>一个子问题的时间</code>为 <code>O(1)</code></p>
<p>综上所述，这个暴力递归算法的时间复杂度为 <code>O(2^n)</code> * <code>O(1)</code> = <code>O(2^n)</code>。</p>
<p>恐怖的指数级别，Boom💥 过后，寸草不生 😱</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>既然时间复杂度如此之高，我们看看能不能做一下优化，首先需要找到导致算法效率低下的原因：</p>
<p>结合上面的递归树图不难看出，在这个递归过程中，存在着大量的重复运算，比如说你想要计算出 f(19) 的结果，那你就必须先计算出 f(18) 和 f(17) 的结果出来，而你计算 f(18) 的时候，需要计算 f(17) 和 f(16)，这个时候，f(17) 就被重复计算了两次。</p>
<p>再仔细看图，以 f(17) 为根的这棵递归树体量巨大，多算一遍，会耗费巨大的时间，而下面还有更多被重复计算的节点，所以导致这个递归算法的效率极低。</p>
<p>既然是因为重复计算导致的算力低下，那么有没有一个好的方案可以解决这种重复计算呢？回想一下五大经典算法：<code>分治</code>、<code>动态规划</code>、<code>贪心</code>、<code>回溯</code>和<code>分支界定</code>，你会发现这个问题非常适合用<code>动态规划</code>来处理，因为它完全符合动态规划问题的第一个性质：<code>重叠子问题</code></p>
<p>明确了问题，其实就已经把问题解决了一半。既然重复计算了，那么我们把计算好的结果存在一个查表里备忘，在遇到重复项时，直接读取查表中的结果，也就避免了重复的计算。</p>
<p>也就是说，每次遇到一个子问题时，先去查表里检查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不再耗时去计算了。</p>
<p>这个查表可以由数组构成，也可以选择哈希表 (字典)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkSheet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 未被计算过</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; memo[n] == <span class="number">0</span>) </span><br><span class="line">        memo[n] = checkSheet(memo, n - <span class="number">1</span>) + </span><br><span class="line">                  checkSheet(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查表全初始化为 0</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始化最简情况</span></span><br><span class="line">    memo[<span class="number">1</span>] = memo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> checkSheet(memo, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再来看下之前的这棵递归树：<br><img src="https://github.com/shevakuilin/GhostPostsImages/raw/master/%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E9%80%92%E5%BD%92%E6%A0%91.png" alt="重复子问题解决递归树"></p>
<p>查表的作用就是把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<p>再回想一下递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。</p>
<p>归功于对冗余计算的「剪枝」，优化后的算法中，子问题个数，即图中节点的总数，子问题 = f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 <code>O(n)</code>。</p>
<p>解决一个子问题的时间，没有任何变化，仍然是只有一个 <code>f(n - 1) + f(n - 2)</code> 加法操作，时间为 <code>O(1)</code>。</p>
<p>所以，本算法的时间复杂度为 <code>O(n)</code> * <code>O(1)</code> = <code>O(n)</code>。和暴力递归的 <code>O(2^n)</code> 比起来，这简直是降维打击 👽。</p>
<p>但这还不是真正意义上的 <code>动态规划</code>，真正的动态规划是「自底向上」的。</p>
<p>递归树是从上向下延伸，是「自顶向下」的。从一个规模较大的原问题，比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案。</p>
<p>而「自底向上」是反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p>下面，我们用动态规划的思想「自底向上」用循环迭代来改造一下这个算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">checkSheet</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    checkSheet[<span class="number">1</span>] = checkSheet[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        checkSheet[i] = checkSheet[i - <span class="number">1</span>] + checkSheet[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> checkSheet[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>「状态转移方程」，实际上就是描述问题结构的数学形式:</p>
<p><strong>斐波那契公式</strong></p>
<p>$$f(n) = \begin{cases} 1, n = 1, 2 \\ f(n - 1) + f(n - 2), n &gt; 2 \end{cases}$$</p>
<p>状态转移方程实际上，就是方程的左半边状态由右半边转移而来，以斐波那契数列公式为例， f(n) 的状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来的，所以叫做状态转移方程。</p>
<p>上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，checkSheet[i] = checkSheet[i - 1] + checkSheet[i - 2]，以及对查表的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<blockquote>
<p>千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。</p>
</blockquote>
<p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个查表来存储所有的状态，只要想办法存储之前的<strong>两个状态</strong>就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>经过上面的分析与算法优化，我们终于可以开始答题了，注意本题的三个要求：</p>
<ol>
<li>多数据输入，直到 <code>EOF</code></li>
<li>第一问 <code>n</code> 的范围是闭区间 <code>[1,200]</code>，第二问是指定输出 <code>fib(8181)</code> 的结果</li>
<li>白板算法，需要写出完整的可执行程序</li>
</ol>
<p>由于需要写出可执行程序，所有引用文件必须得到声明，在此基础上，我们来完成第一条要求，多数据输入:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = fib(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就结束了吗，恰恰相反，不仅没有结束，本题的陷阱已经悄然展现在你面前，注意第二点要求，这是一个 <code>[1,200]</code> 的闭区间，后面还有第二问，<code>fib(8181)</code>。</p>
<p>这意味着什么呢？意味着你设计的程序需要处理 <code>f(200)</code> 和 <code>f(8181)</code> 这样的边界条件，回想一下上面的那棵树，即使经过剪枝，仍然是庞大的数量计算。</p>
<p>而这会带来什么样的结果呢？答案是 <code>赋值越界</code>。</p>
<p>由于计算中产生的数值结果远远超出了 <code>C/C++</code> 等语言中整型所能存储的最大范围，会导致整数的赋值越界的问题，程序会在执行过程中发生崩溃，这样设计的程序是肯定无法通过的。</p>
<p>所以，为了规避<code>赋值越界</code>，我们需要对这样的「大数」进行<code>模拟计算</code>，将庞大的整型数值替换为字符串来计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">findSum</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始计算之前，确保 str2 的长度更大</span></span><br><span class="line">    <span class="keyword">if</span> (str1.length() &gt; str2.length()) &#123;</span><br><span class="line">        swap(str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用一个空字符串存储结果</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算两个字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> n1 = str1.length(), n2 = str2.length();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 反转两个字符串</span></span><br><span class="line">    reverse(str1.begin(), str1.end());</span><br><span class="line">    reverse(str2.begin(), str2.end());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n1; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算当前数字的总和并进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = ((str1[i]-<span class="string">&#x27;0&#x27;</span>)+(str2[i]-<span class="string">&#x27;0&#x27;</span>)+carry);</span><br><span class="line">        str.push_back(sum%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 计算下一步的进位</span></span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上 str2 的其余位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n1; i&lt;n2; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = ((str2[i]-<span class="string">&#x27;0&#x27;</span>)+carry);</span><br><span class="line">        str.push_back(sum%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入剩余进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        str.push_back(carry+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向结果字符串</span></span><br><span class="line">    reverse(str.begin(), str.end());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> to_string(n);</span><br><span class="line">    <span class="built_in">string</span> prev = <span class="string">&quot;0&quot;</span>, curr = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> sum = findSum(prev, curr);</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n) &#123;</span><br><span class="line">        <span class="built_in">string</span> result = fib(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完美解决了三点要求，至此，题解结束 👊。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>当然，你可以使用 <code>Python</code> 或者 <code>Java</code> 这类拥有 <code>BigInteger</code>的语言来写这道题目，因为并没有语言限制，但是这样就失去了题目本身考察的意义。</p>
<p>———— 2019.11.14 更新 ————</p>
<p><code>Swift</code> 最新的 Future plans 中，也准备支持支持超高精度大数了，<code>Swift</code> 将支持大于 64 位的固定宽度整数类型。</p>
<p><code>Swift</code> 开源社区宣布了一项新的生态系统项目：<code>Swift Numerics</code>, <code>Swift Numerics</code> 将为 <code>Swift</code> 中的数值计算提供构建模块，其目的是为了填补现有标准库当中的 API 空白，就比如对超高精度大数的支持。</p>
<p>详情见：<br><a target="_blank" rel="noopener" href="https://github.com/apple/swift-numerics/issues/4">Fixed-width integer types</a><br><a target="_blank" rel="noopener" href="https://swift.org/blog/numerics/">Swift Numerics</a></p>
<p>————- 更新内容结束 ————-</p>
<p>下面是 <code>Python</code> 版本的题解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">sum</span> = a + b</span><br><span class="line">        a,b = b,<span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment">#多组测试数据，处理到文件结束。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        r = fib(n)</span><br><span class="line">        print(r)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/di-gui-xiang-jie">递归详解</a><br><a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-xiang-jie">动态规划详解</a></p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/11/13/graph-cycle/" title="判断图中是否存在环">判断图中是否存在环</a></h2>
                <p class="excerpt">
                
                使用「深度优先搜索」来判断图中是否存在回路，该题目出自 2018 年阿里巴巴手机淘宝 iOS 客户端架构组应届生面试题目。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-11-13T08:19:43.000Z" class="post-list__meta--date date">2019-11-13</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%8C%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%8C%E7%8E%AF%E8%B7%AF/" rel="tag">深度优先搜索, 有向图，无向图，环路</a>
</span><a class="btn-border-small" href="/2019/11/13/graph-cycle/">开始阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/11/12/dcep-dollarkiller/" title="数字货币DCEP--美元霸权的终结者">数字货币DCEP--美元霸权的终结者</a></h2>
                <p class="excerpt">
                
                关于央行发行的数字货币DCEP，和区块链技术未来在国内发展应用趋势的一点思考和看法
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-11-11T18:05:32.000Z" class="post-list__meta--date date">2019-11-12</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/DCEP-%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81-%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%BE%8E%E5%85%83%E9%9C%B8%E6%9D%83/" rel="tag">DCEP, 数字货币, 区块链, 美元霸权</a>
</span><a class="btn-border-small" href="/2019/11/12/dcep-dollarkiller/">开始阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2020 ShevaKuilin - 跃迁引擎 <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"> 渝ICP备 19012091</a>, 本站点采用 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> 搭建，使用 <a target="_blank" rel="noopener" href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a target="_blank" rel="noopener" href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
  
         <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
    
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
   
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
