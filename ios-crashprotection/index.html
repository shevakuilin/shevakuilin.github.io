<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS Research &amp; Development">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎">
    <meta name="twitter:description" content="iOS Research &amp; Development">

    <meta property="og:type" content="article">
    <meta property="og:title" content="浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎">
    <meta property="og:description" content="iOS Research &amp; Development">

    
    <meta name="author" content="ShevaKuilin">
    
    
<link rel="stylesheet" href="/css/vno.css">

    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">


    
    <link rel="icon" href="/images/favicon.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://shevakuilin.com/ios-crashprotection/"/>

                 
</head>

<body class="home-template no-js">
    
<script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>

    
<script src="/js/main.js"></script>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 跃迁引擎 的主页"><img src="/images/avatar.jpeg" width="80" alt="跃迁引擎 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 跃迁引擎">跃迁引擎</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">空気を読んだ雨降らないでよ</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">iOS Research & Development</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">主页</a></li>
            
              <li class="navigation__item"><a href="/archives">所有文章</a></li>
            
              <li class="navigation__item"><a href="/tags/算法/">算法</a></li>
            
              <li class="navigation__item"><a href="/tags/iOS/">iOS</a></li>
            
              <li class="navigation__item"><a href="/tags/AI/">AI</a></li>
            
              <li class="navigation__item"><a href="/tags/HarmonyOS/">HarmonyOS</a></li>
            
              <li class="navigation__item"><a href="/tags/Rust/">Rust</a></li>
            
              <li class="navigation__item"><a href="/tags/札记/">札记</a></li>
            
              <li class="navigation__item"><a href="/tags/随笔/">随笔</a></li>
            
              <li class="navigation__item"><a href="/tags/折腾日记/">折腾日记</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/shevakuilin" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-05-01T05:25:25.000Z" class="post-list__meta--date date">2020-05-01</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="-none-link" href="/tags/Crash/" rel="tag">Crash</a>, <a class="-none-link" href="/tags/iOS/" rel="tag">iOS</a>
 </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">浅谈 iOS 中的 Crash 捕获与防护</h1>
  </header>

  <section class="post">
    <p>五一假期的第一天，闲来无事，今天来聊一聊 iOS 中的 Crash 捕获与防护。<span id="more"></span></p>
<img src="https://github.com/shevakuilin/GhostPostsImages/raw/master/63238926_p0_master1200.jpg">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工程师们苦 Crash 久矣，尤其是用户感知最为明显的客户端。那居高不下的崩溃率、数不胜数的用户反馈、迟迟无法完成的 KPI，折磨着每一位客户端的开发同学。</p>
<blockquote>
<p>加断点再Debug，堆栈瞬间就爆炸，日志输出如雨下，看到异常就害怕；调试一夜没人陪，心想这锅该归谁？回想当初心后悔，不该重构这地雷；翻日志查半天，博客看了千百遍，低头又点一根烟，闪退还是没复现。</p>
</blockquote>
<p>上面这段文字很形象的描述了一位深夜排查闪退问题的工程师。那么 Crash 为何如此难以解决且反复发作，它究竟难在哪里，从客户端工程诞生至今一直困扰着无数的工程师。</p>
<h2 id="主动出击"><a href="#主动出击" class="headerlink" title="主动出击"></a>主动出击</h2><blockquote>
<p>进攻是最好的防守。</p>
</blockquote>
<p>在工作中，你不能总是守株待兔，期待 Crash 自己找上门来，主动躺在你的 Todolist 里。你需要在问题大面积爆发前，提前感知，迅速解决，就像碟中谍里的汤姆斯·布鲁克，在悄然无息间拯救地球，深藏功与名。</p>
<p>我们需要一套 Crash 主动防护机制，来帮助工程师们快速处理这些问题。</p>
<p>防护的核心是定位，定位问题的前提是能够发现问题，首先需要做的是捕获到异常然后将其上报。</p>
<h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><p>市面上能够找到的统计崩溃等异常的 SDK 非常多，友盟、Bugly、GrowingIO 等等，他们通常都是将捕获到的信息日志上传到对应的服务器上，以此来做一些后续的统计和分析。在一些规模较小的团队当中，无法面面俱到，直接引用这些 SDK 是可以接收的，但如果你的团队对应用性能有一定要求，那么这些 SDK 就会显得有些 “不够用” 了。</p>
<p>作者对市面上主流的统计 SDK 都有过较长时间的使用经验，发现无论哪一家 SDK 都有或多或少存在着两个通病：<strong>上报延迟</strong>  和 <strong>定位表述模糊</strong>。</p>
<p>我们要在用户感知之前提前发现问题，就需要在研发和提测阶段尽可能早的暴露出问题，这样一来可以在崩溃现场或第一时间捕获崩溃信息，然后将崩溃堆栈信息及时反馈给我们的工程师，也会大大提高测试和开发之前的沟通效率。</p>
<p>由于上述 SDK 存在的问题，所以这部分工作就需要我们自己来进行补充。</p>
<h3 id="Crash-捕获"><a href="#Crash-捕获" class="headerlink" title="Crash 捕获"></a>Crash 捕获</h3><p>我们需要先了解 iOS 发生崩溃的底层原理，下面是 Crash 捕获处理系统几个核心的关键领域知识。</p>
<ul>
<li>UNIX signals 信号</li>
<li>Mach Exceptions Mach异常</li>
<li>Basic Thread details 线程现场信息</li>
<li>Binary image information 动态库信息</li>
<li>Frame pointer-based stack traces 基于 fp 的 callstack 回溯</li>
<li>Compact Unwind support 辅助 callstack 回溯的 Compact Unwind 信息</li>
</ul>
<p><strong>在这里我们主要是针对 Mach异常 和 UNIX信号 的处理。</strong></p>
<h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>首先要明确几个概念及其之间的联系：<code>硬件异常</code>, <code>软件异常</code>,<code>mach异常</code>, <code>Signal异常</code>。这四种异常概念，自底向上构建了iOS系统的异常处理模型。</p>
<p>其之间的关系如下:</p>
<img src="/image/exception.png" style="zoom:50%">

<h4 id="Mach异常与Signal"><a href="#Mach异常与Signal" class="headerlink" title="Mach异常与Signal"></a>Mach异常与Signal</h4><p>iOS 中的 Crash 主要分为<code>Mach Exception</code>、<code>Singal</code>、<code>NSException</code>三种类型，每一种类型的 Crash 都处在不同的系统层级上，也有各自不同的捕获方式。</p>
<img src="/image/kernel.png" style="zoom:50%">

<h5 id="Mach-Exception"><a href="#Mach-Exception" class="headerlink" title="Mach Exception"></a>Mach Exception</h5><p>Mach是一个XNU的微内核核心，Mach异常是指最底层的内核级异常，被定义在 <code>&lt;mach/exception_types.h&gt;</code>下 。Mach异常由CPU陷阱引发，在异常发生后会被异常处理程序转换成Mach消息，接着依次投递到<code>thread</code>、<code>task</code>和<code>host</code>端口。</p>
<p>如果没有上述任何一个端口来处理这个异常并返回<code>KERN_SUCCESS</code>，那么应用将被终止。每个端口都拥有一个异常端口数组，系统暴露了后缀为<code>_set_exception_ports</code>的多个 API 让我们注册对应的异常处理到端口中，用以来捕获Mach异常，抓取Crash事件。</p>
<p>在Mach中，异常是通过内核中的主要设施<strong>消息传递机制</strong>进行处理的。一个异常与一条消息并无差别，由出错的线程或任务（通过 <code>msg_send()</code>）发送，并通过一个处理程（通过 <code>msg_recv()</code>）接收。<br> 由于Mach的异常以消息机制处理而不是通过函数调用，exception messages可以被转发到先前注册的Mach exception处理程序。这意味着你可以插入一个exception处理程序，而不干扰现有的无论是调试器或Apple’s crash reporter。可以使用<code>mach_msg() // flag MACH_SEND_MSG</code>发送原始消息到以前注册的处理程序的Mach端口，将消息转发到一个现有的处理程序。</p>
<p>综上所述，基于 mach message 机制, 可以</p>
<ul>
<li>通过注册端口监听异常消息（可以为 host, task, thread 注册异常处理端口）</li>
<li>发送异常消息</li>
</ul>
<h4 id="Mach异常与Signal的转换"><a href="#Mach异常与Signal的转换" class="headerlink" title="Mach异常与Signal的转换"></a>Mach异常与Signal的转换</h4><p>Mach异常如果不处理，默认会转化为Signal异常（所有Mach异常都默认在<code>host</code>层被<code>ux_exception</code>转换为相应的Signal，并通过<code>threadsignal</code>将信号投递到出错的线程）。如：<code>EXC_BAD_ACCESS(SIGSEGV)</code>表示的意思就是：Mach层的EXC_BAD_ACCESS异常，在host层被转换成SIGSEGV信号投递到出错的线程。<br>其中内核注册了host-level的exception handler，负责将mach异常转换为对应的Signal信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called with kernel funnel held */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">bsdinit_task</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">proc_t</span> p = <span class="built_in">current_proc</span>();</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">uthread</span> *ut;</span><br><span class="line">	<span class="type">thread_t</span> thread;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">process_name</span>(<span class="string">&quot;init&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ux_handler_init</span>();</span><br><span class="line"></span><br><span class="line">	thread = <span class="built_in">current_thread</span>();</span><br><span class="line">	(<span class="type">void</span>) <span class="built_in">host_set_exception_ports</span>(<span class="built_in">host_priv_self</span>(),</span><br><span class="line">					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">					(<span class="type">mach_port_t</span>) ux_exception_port,</span><br><span class="line">					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (<span class="type">uthread_t</span>)<span class="built_in">get_bsdthread_info</span>(thread);</span><br><span class="line"></span><br><span class="line">	bsd_init_task = <span class="built_in">get_threadtask</span>(thread);</span><br><span class="line">	init_task_failure_data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	<span class="built_in">mac_cred_label_associate_user</span>(p-&gt;p_ucred);</span><br><span class="line">	<span class="built_in">mac_task_label_update_cred</span> (p-&gt;p_ucred, (<span class="keyword">struct</span> task *) p-&gt;task);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">load_init_program</span>(p);</span><br><span class="line">	lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mach异常信号的来源，主要通过两种途径：</p>
<ul>
<li>硬件级别的触发异常</li>
<li>proc退出时会触发异常(EXC_CRASH)。</li>
</ul>
<img src="/image/exception_triage.png" style="zoom:50%">

<h4 id="Mach异常与软硬件异常"><a href="#Mach异常与软硬件异常" class="headerlink" title="Mach异常与软硬件异常"></a>Mach异常与软硬件异常</h4><h5 id="硬件异常触发流程"><a href="#硬件异常触发流程" class="headerlink" title="硬件异常触发流程"></a>硬件异常触发流程</h5><img src="/image/hardware_mach.png" style="zoom:50%">

<p>硬件异常会转化为Mach异常</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">i386_exception(</span><br><span class="line">	<span class="type">int</span>	exc,</span><br><span class="line">	mach_exception_code_t code,</span><br><span class="line">	mach_exception_subcode_t subcode)</span><br><span class="line">&#123;</span><br><span class="line">	mach_exception_data_type_t   codes[EXCEPTION_CODE_MAX];</span><br><span class="line"></span><br><span class="line">	DEBUG_KPRINT_SYSCALL_MACH(<span class="string">&quot;i386_exception: exc=%d code=0x%llx subcode=0x%llx\n&quot;</span>,</span><br><span class="line">							  exc, code, subcode);</span><br><span class="line">	codes[<span class="number">0</span>] = code;		<span class="comment">/* new exception interface */</span></span><br><span class="line">	codes[<span class="number">1</span>] = subcode;</span><br><span class="line">	exception_triage(exc, codes, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">/*NOTREACHED*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">exception_triage(</span><br><span class="line">	exception_type_t	exception,</span><br><span class="line">	mach_exception_data_t	code,</span><br><span class="line">	mach_msg_type_number_t  codeCnt)</span><br><span class="line">&#123;</span><br><span class="line">	thread_t		thread;</span><br><span class="line">	task_t			task;</span><br><span class="line">	host_priv_t		host_priv;</span><br><span class="line">	lck_mtx_t		*mutex;</span><br><span class="line">	kern_return_t	kr;</span><br><span class="line"></span><br><span class="line">	assert(exception != EXC_RPC_ALERT);</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to raise the exception at the activation level.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex = &amp;thread-&gt;mutex;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, thread-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Maybe the task level will handle it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	task = current_task();</span><br><span class="line">	mutex = &amp;task-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, task-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * How about at the host level?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	host_priv = host_priv_self();</span><br><span class="line">	mutex = &amp;host_priv-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, host_priv-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Nobody handled it, terminate the task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) task_terminate(task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	<span class="keyword">if</span> ((exception != EXC_CRASH) &amp;&amp; (exception != EXC_RESOURCE) &amp;&amp;</span><br><span class="line">	    (exception != EXC_GUARD))</span><br><span class="line">		thread_exception_return();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="软件异常"><a href="#软件异常" class="headerlink" title="软件异常"></a>软件异常</h5><p>处理流程如下图所示：</p>
<img src="/image/kill.png" style="zoom:50%">

<p>通过kill() 直接抛出signal异常，这里需要<strong>注意</strong>，网上有些观点认为</p>
<blockquote>
<p>因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用kill和pthread_kill)也首先沉下来被转换为Mach异常，再转换为Unix信号。</p>
<p>软件异常的处理流程：abort()-&gt; kill()&#x2F;pthread_kill信号-&gt; Mach异常-&gt; Unix信号（SIGABRT）</p>
</blockquote>
<p>也就是说，软件异常与硬件异常相同，都是先转为Mach异常，再转换成的Signal。</p>
<p>但这个观点经过验证后发现是站不住脚的，如果按照此观点所说，那么我们在软件异常发生时，只实现mach exceptiona捕获，是可以抓到abort的；但如果你去试验一下会发现是抓不到abort的，这也就意味着<strong>在软件异常发生后根本就没有走mach exceptiona的流程</strong>。</p>
<p>软件产生的信号来自<code>kill()</code>、<code>pthread_kill()</code>两个函数的调用，大概过程是这样的：<code>kill()</code>&#x2F;<code>pthread_kill()</code> –&gt; <code>...</code> –&gt; <code>psignal_internal()</code> –&gt; <code>act_set_astbsd()</code>。最终也会调用<code>act_set_astbsd()</code>发送信号到目标线程。</p>
<p>abort()的源码也印证了这一点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__private_extern__ <span class="type">void</span></span><br><span class="line">__abort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> sigaction act;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!CRGetCrashLogMessage())</span><br><span class="line">		CRSetCrashLogMessage(<span class="string">&quot;__abort() called&quot;</span>);</span><br><span class="line">	act.sa_handler = SIG_DFL;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	(<span class="type">void</span>)_sigaction(SIGABRT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGABRT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread </span></span><br><span class="line"><span class="comment">	 * This helps gdb focus on the thread calling abort()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (__is_threaded) &#123;</span><br><span class="line">	    <span class="comment">/* Block all signals on all other threads */</span></span><br><span class="line">	    sigset_t fullmask;</span><br><span class="line">	    sigfillset(&amp;fullmask);</span><br><span class="line">	    (<span class="type">void</span>)_sigprocmask(SIG_SETMASK, &amp;fullmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* &lt;rdar://problem/8400096&gt; Set the workqueue killable */</span></span><br><span class="line">	    __pthread_workqueue_setkill(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    (<span class="type">void</span>)pthread_sigmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="type">void</span>)pthread_kill(pthread_self(), SIGABRT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    (<span class="type">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="type">void</span>)kill(getpid(), SIGABRT);</span><br><span class="line">	&#125;</span><br><span class="line">	usleep(TIMEOUT); <span class="comment">/* give time for signal to happen */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If for some reason SIGABRT was not delivered, we exit using __builtin_trap</span></span><br><span class="line"><span class="comment">	 * which generates an illegal instruction on i386: &lt;rdar://problem/8400958&gt;</span></span><br><span class="line"><span class="comment">	 * and SIGTRAP on arm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGILL);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGTRAP);</span><br><span class="line">	(<span class="type">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	__builtin_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在abort()源码注释着：<code>&lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread</code> , 它是这样调用的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">void</span>)pthread_kill(pthread_self(), SIGABRT);</span><br></pre></td></tr></table></figure>

<p>这里也可以看出，软件异常并不是转换为Mach再转换到Signal，而是直接转换为Signal的。</p>
<h4 id="EXC-CRASH"><a href="#EXC-CRASH" class="headerlink" title="EXC_CRASH"></a>EXC_CRASH</h4><p>为何以像<a target="_blank" rel="noopener" href="https://toutiao.io/posts/ziqho/preview">《漫谈 iOS Crash 收集框架》</a>这些文章会得出“首先沉下来被转换为Mach异常，再转换为Unix信号”这样的结论呢？我想大概是被 <code>EXC_CRASH</code> 所误导了。</p>
<p>系统通过launchd监听了EXC_CRASH。而 <code>EXC_CRASH</code> 是一种特殊类型，<strong>囊括硬件和软件异常</strong>，它什么都能抓。但是因为信号发出的时候，进程已经跪了，所以需要 out-of-process 处理。</p>
<p>看进程退出逻辑，EXC_CRASH 基本上会囊括所有的崩溃类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">proc_prepareexit(proc_t p, <span class="type">int</span> rv, boolean_t perf_notify) </span><br><span class="line">&#123;</span><br><span class="line">	mach_exception_data_type_t code, subcode;</span><br><span class="line">	<span class="keyword">struct</span> uthread *ut;</span><br><span class="line">	thread_t <span class="keyword">self</span> = current_thread();</span><br><span class="line">	ut = get_bsdthread_info(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/* If a core should be generated, notify crash reporter */</span></span><br><span class="line">	<span class="keyword">if</span> (hassigprop(WTERMSIG(rv), SA_CORE) || ((p-&gt;p_csflags &amp; CS_KILLED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * Workaround for processes checking up on PT_DENY_ATTACH:</span></span><br><span class="line"><span class="comment">		 * should be backed out post-Leopard (details in 5431025).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((SIGSEGV == WTERMSIG(rv)) &amp;&amp; </span><br><span class="line">				(p-&gt;p_pptr-&gt;p_lflag &amp; P_LNOATTACH)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> skipcheck;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Crash Reporter looks for the signal value, original exception</span></span><br><span class="line"><span class="comment">		 * type, and low 20 bits of the original code in code[0] </span></span><br><span class="line"><span class="comment">		 * (8, 4, and 20 bits respectively). code[1] is unmodified. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		code = ((WTERMSIG(rv) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">			((ut-&gt;uu_exception &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">20</span>) | </span><br><span class="line">			((<span class="type">int</span>)ut-&gt;uu_code &amp; <span class="number">0xfffff</span>);</span><br><span class="line">		subcode = ut-&gt;uu_subcode;</span><br><span class="line">		(<span class="type">void</span>) task_exception_notify(EXC_CRASH, code, subcode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">skipcheck:</span><br><span class="line">	<span class="comment">/* Notify the perf server? */</span></span><br><span class="line">	<span class="keyword">if</span> (perf_notify) &#123;</span><br><span class="line">		(<span class="type">void</span>)sys_perf_notify(<span class="keyword">self</span>, p-&gt;p_pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remove proc from allproc queue and from pidhash chain.</span></span><br><span class="line"><span class="comment">	 * Need to do this before we do anything that can block.</span></span><br><span class="line"><span class="comment">	 * Not doing causes things like mount() find this on allproc</span></span><br><span class="line"><span class="comment">	 * in partially cleaned state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	proc_list_lock();</span><br><span class="line"></span><br><span class="line">	LIST_REMOVE(p, p_list);</span><br><span class="line">	LIST_INSERT_HEAD(&amp;zombproc, p, p_list);	<span class="comment">/* Place onto zombproc. */</span></span><br><span class="line">	<span class="comment">/* will not be visible via proc_find */</span></span><br><span class="line">	p-&gt;p_listflag |= P_LIST_EXITED;</span><br><span class="line"></span><br><span class="line">	proc_list_unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PGINPROF</span></span><br><span class="line">	vmsizmon();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If parent is waiting for us to exit or exec,</span></span><br><span class="line"><span class="comment">	 * P_LPPWAIT is set; we will wakeup the parent below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_lflag &amp;= ~(P_LTRACED | P_LPPWAIT);</span><br><span class="line">	p-&gt;p_sigignore = ~(sigcantmask);</span><br><span class="line">	ut-&gt;uu_siglist = <span class="number">0</span>;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在通知 Apple’s Crash Reporter 的时候，会把所有类型的的mach exception type都记为EXC_CRASH，自然也包括了SIGABRT</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception Type: EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: <span class="number">0x0000000000000000</span>, <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>所以，软&#x2F;硬件异常最终都会转化为Signal信号，但他们的处理流程是<strong>不同的</strong>。</p>
<h4 id="Jetsam"><a href="#Jetsam" class="headerlink" title="Jetsam"></a>Jetsam</h4><p>MacOS&#x2F;iOS是一个从BSD衍生而来的系统。其内核是Mach，但是对于上层暴露的接口一般都是基于BSD层对于Mach包装后的。虽然说Mach是个微内核的架构，真正的虚拟内存管理是在其中进行，但是BSD对于内存管理提供了相对较为上层的接口，同时，各种常见的<strong>JetSam事件也是由BSD产生</strong>。</p>
<p>关于Jetsam，可能有些人还不是很理解。我们可以从<strong>手机设置-&gt;隐私-&gt;分析</strong>这条路径看看系统的日志，会发现手机上有许多<code>JetsamEvent</code>开头的日志。打开这些日志，一般会显示一些内存大小，CPU时间什么的数据。</p>
<p>之所以会发生这么JetsamEvent，主要还是由于iOS设备不存在交换区导致的内存受限，所以iOS内核不得不把一些<strong>优先级不高或者占用内存过大的</strong>杀掉。这些<code>JetsamEvent</code>就是系统在杀掉App后记录的一些数据信息。</p>
<p>从某种程度来说，JetsamEvent是一种另类的Crash事件，但是在常规的Crash捕获工具中，<strong>由于iOS上能捕获的信号量的限制，所以因为内存导致App被杀掉是无法被捕获的</strong>。</p>
<p>篇幅有限，这里不做过多介绍，感兴趣可以自行了解。</p>
<h4 id="Mach异常与Signal的选择"><a href="#Mach异常与Signal的选择" class="headerlink" title="Mach异常与Signal的选择"></a>Mach异常与Signal的选择</h4><h5 id="该捕获谁？"><a href="#该捕获谁？" class="headerlink" title="该捕获谁？"></a>该捕获谁？</h5><p>捕获Mach异常或者Signal都可以抓到Crash事件，这两种方式哪个更好呢？</p>
<p>理论上优选Mach异常，因为Mach异常处理会先于Signal处理发生，如果Mach异常的handler让程序exit了，那么Signal就永远不会到达这个进程了。</p>
<h5 id="为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？"><a href="#为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？" class="headerlink" title="为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？"></a>为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？</h5><blockquote>
<p>We still need to use signal handlers to catch SIGABRT in-process. The kernel sends an EXC_CRASH mach exception to denote SIGABRT termination. In that case, catching the Mach exception in-process leads to process deadlock in an uninterruptable wait. Thus, we fall back on BSD signal handlers for SIGABRT, and do not register for EXC_CRASH.</p>
</blockquote>
<h3 id="Signal的捕获"><a href="#Signal的捕获" class="headerlink" title="Signal的捕获"></a>Signal的捕获</h3><p>从上面的结论可以看出，尽管Mach exception handle 比 UNIX signal handle 更有优势，但我们还是须要注册signal handle用于处理EXC_SOFTWARE&#x2F;EXC_CRASH。</p>
<p>既然异常最终都会转换为Signal信号，那么我们可以将如何捕获<code>Mach Exception</code>的注意力转移到如何捕获<code>Signal</code>上了。</p>
<p>UNIX signals是一套基于<code>POSIX标准</code>开发的通信机制，POSIX API 就是通过 Mach 之上的 BSD 层实现的。</p>
<img src="/image/posix-bsd-mach.png" style="zoom:50%">

<p>在<code>signal.h</code>中声明了32种异常信号，以下六种为iOS常见的信号，它们均会导致程序崩溃。</p>
<table>
<thead>
<tr>
<th align="left">信号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGILL</td>
<td align="left">执行了非法指令，一般是可执行文件出现了错误</td>
</tr>
<tr>
<td align="left">SIGTRAP</td>
<td align="left">断点指令或者其他trap指令产生</td>
</tr>
<tr>
<td align="left">SIGABRT</td>
<td align="left">调用abort产生</td>
</tr>
<tr>
<td align="left">SIGBUS</td>
<td align="left">非法地址。比如错误的内存类型访问、内存地址对齐等</td>
</tr>
<tr>
<td align="left">SIGSEGV</td>
<td align="left">非法地址。访问未分配内存、写入没有写权限的内存等</td>
</tr>
<tr>
<td align="left">SIGFPE</td>
<td align="left">致命的算术运算。比如数值溢出、NaN数值等</td>
</tr>
</tbody></table>
<p>Signal可以通过注册信号处理函数来捕获:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装有6种常见信号的信号数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// - Note: signalExceptionHandler 为捕获后的回调函数</span></span><br><span class="line">    signal([signals[index] intValue], &amp;SignalExceptionHandler);</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> SignalExceptionHandler(<span class="type">int</span> signo) &#123;</span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Signal的调试"><a href="#Signal的调试" class="headerlink" title="Signal的调试"></a>Signal的调试</h4><h3 id="NSException异常的捕获"><a href="#NSException异常的捕获" class="headerlink" title="NSException异常的捕获"></a>NSException异常的捕获</h3><p><code>NSException</code>就属于我们前面所说的软件异常。它是应用级异常，发生在<code>CoreFoundation</code>以及更高抽象层级，会通过<code>__cxa_throw</code>函数抛出异常。如果没有人为进行捕获或者在捕获回调函数中没有进行操作终止应用，那么最终会通过<code>abort()</code>函数来向进程抛出一个<code>SIGABRT</code>的信号。</p>
<p><code>NSException</code>可以通过<code>@try-@catch</code>机制捕获，以此来避免应用Crash。同样地，如果没有catch处理，那么会被系统自带的错误处理所捕获，这个时候可以通过注册<code>NSUncaughtExceptionHandler</code>来捕获NSException异常。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册NSUncaughtExceptionHandler</span></span><br><span class="line"><span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃时的回调函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> * exception) &#123;</span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免覆盖"><a href="#避免覆盖" class="headerlink" title="避免覆盖"></a>避免覆盖</h4><p>如文章开头所提，我们的工程里可能已经包含一个或多个第三方的统计SDK，他们大多数都是基于<code>NSUncaughtExceptionHandler</code>进行崩溃收集。那么这个时候，一个不可避免的问题就产生了：由于<code>NSSetUncaughtExceptionHandler</code>函数存在覆盖现象，后注册的总会顶替掉前面注册的，当Crash发生时，永远只会触发最后注册传入的捕获回调函数。</p>
<p>而各家的SDK都会以保证自己的Crash统计正确完整为目的，难免出现强行覆盖等等的恶意竞争，就可能导致在其之前注册过的日志收集服务写出的Crash日志因为取不到NSException而丢失Last Exception Backtrace等重要信息。</p>
<p>所以正确的作法是：总是通过NSGetUncaughtExceptionHandler将之前别人注册的handler取出并备份（因为你可能并不清楚自己真正的注册顺序，所以最好每次都这么做），在自己handler处理完后记得把别人的handler注册回去，形成规范的SOP。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录之前的Crash回调函数（如果有的话）</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUncaughtExceptionHandler</span> *previousUncaughtExceptionHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)registerUncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="comment">// 将别人之前注册的Crash回调取出并备份</span></span><br><span class="line">    previousUncaughtExceptionHandler = <span class="built_in">NSGetUncaughtExceptionHandler</span>();</span><br><span class="line">    <span class="comment">// 然后再注册自己的</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃时的回调函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> * exception) &#123;</span><br><span class="line">    <span class="comment">// 异常的堆栈信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *stackInfo = [exception callStackSymbols];</span><br><span class="line">    <span class="comment">// 出现异常的原因</span></span><br><span class="line">    <span class="built_in">NSString</span> *reason = [exception reason];</span><br><span class="line">    <span class="comment">// 异常名称</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = [exception name];</span><br><span class="line">    <span class="comment">// 异常错误报告</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;uncaughtException异常错误报告:\n name:%@\n reason:\n %@\n callStackSymbols:\n %@&quot;</span>, name, reason, [stackInfo componentsJoinedByString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    <span class="comment">// 保存Crash日志到沙盒cache目录</span></span><br><span class="line">    [<span class="built_in">SKTool</span> cacheCrashLog:exceptionInfo name:<span class="string">@&quot;CrashLog(UncaughtException)&quot;</span>];</span><br><span class="line">    <span class="comment">// 在自己handler处理完后记得把别人的handler注册回去，形成规范的SOP</span></span><br><span class="line">    <span class="keyword">if</span> (previousUncaughtExceptionHandler) &#123;</span><br><span class="line">        previousUncaughtExceptionHandler(exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 杀掉程序，这样可以防止同时抛出的SIGABRT被Signal异常捕获</span></span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于断点调试"><a href="#关于断点调试" class="headerlink" title="关于断点调试"></a>关于断点调试</h3><h4 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h4><p>因为Xcode屏蔽了Signal的回调，我们需要在<code>lldb</code>中输入以下命令，Signal的回调才可以进来</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro hand -p <span class="literal">true</span> -s <span class="literal">false</span> <span class="variable constant_">SIGABRT</span></span><br></pre></td></tr></table></figure>

<h4 id="NSSetUncaughtExceptionHandler"><a href="#NSSetUncaughtExceptionHandler" class="headerlink" title="NSSetUncaughtExceptionHandler"></a>NSSetUncaughtExceptionHandler</h4><p>在开发测试阶段，可以利用 <a target="_blank" rel="noopener" href="https://github.com/facebook/fishhook">fishhook</a> 框架去hook <code>NSSetUncaughtExceptionHandler</code>方法，这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。不推荐利用调试器添加符号断点来检查，原因是一些Crash收集框架或统计SDK在调试状态下是不工作的。</p>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>在调试阶段我们可能会看到许多crash callstack信息，下面列了几个常见的对应关系：</p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x8badf00d</td>
<td align="left">在启动、终止应用或响应系统事件花费过长时间，意思是”ate bad food”。</td>
</tr>
<tr>
<td align="left">0xdeadfa11</td>
<td align="left">用户强制退出,意为”dead fall”。(系统无响应时,用户按电源开关和HOME)</td>
</tr>
<tr>
<td align="left">0xbaaaaaad</td>
<td align="left">用户按住Home键和音量键，获取当前内存状态，不代表崩溃</td>
</tr>
<tr>
<td align="left">0xbad22222</td>
<td align="left">VoIP应用因为恢复得太频繁导致Crash</td>
</tr>
<tr>
<td align="left">0xc00010ff</td>
<td align="left">因为太烫了被干掉，意为”cool off”</td>
</tr>
<tr>
<td align="left">0xdead10cc</td>
<td align="left">因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为”dead lock”</td>
</tr>
</tbody></table>
<h3 id="线程保活提醒"><a href="#线程保活提醒" class="headerlink" title="线程保活提醒"></a>线程保活提醒</h3><p>按照我们之前所说，需要在崩溃现场或第一时间捕获崩溃信息，然后将崩溃堆栈信息及时反馈给我们的工程师。但是崩溃发生后，程序在完成回调后会立刻被杀死，在被杀死后无法进行任何后续操作，那么该怎么做呢？</p>
<h4 id="利用Runloop"><a href="#利用Runloop" class="headerlink" title="利用Runloop"></a>利用Runloop</h4><p>我们可以像这样创建一个<code>Runloop</code>，将主线程的所有<code>Runmode</code>都拿过来跑，作为应用程序主Runloop的替代。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFArrayRef</span> allModes = <span class="built_in">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class="line"><span class="keyword">while</span> (!dismissed) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)allModes) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(allModes);</span><br></pre></td></tr></table></figure>

<p>这样固然可以实现我们想要做的事情，但是会带来一个问题：因为我们为了继续执行程序而没有将控制权返回给导致崩溃的调用函数，并且我们启动了自己的<code>Runloop</code>，所以永远不会返回到原始的<code>Runloop</code>中去了，这将意味着导致异常的线程使用的<code>堆栈内存</code>将永久泄漏。因此这种类型的方法应被视为调试工具或最后手段，所以，不要在Debug以外的环境使用它。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> InstallUncaughtExceptionHandler(<span class="type">void</span>) &#123;</span><br><span class="line">	<span class="comment">// 注册 NSException</span></span><br><span class="line">	<span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;HandleException); </span><br><span class="line"> 	<span class="comment">// 注册 Signal</span></span><br><span class="line"> 	<span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    	signal([signals[index] intValue], &amp;SignalExceptionHandler);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> HandleException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="comment">// OSAtomicIncrement32是一个递增的一个全局计数器，既快速又安全，是为了防止并发数太大出现错误的情况。</span></span><br><span class="line">    int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);</span><br><span class="line">    <span class="keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 获取堆栈信息的数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *callStack = [<span class="built_in">SKUncaughtExceptionHandler</span> backtrace];</span><br><span class="line">    <span class="comment">// 设置该字典</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *userInfo =</span><br><span class="line">    [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:[exception userInfo]];</span><br><span class="line">    <span class="comment">// 给堆栈信息设置地址Key</span></span><br><span class="line">    [userInfo</span><br><span class="line">     setObject:callStack</span><br><span class="line">     forKey:UncaughtExceptionHandlerAddressesKey];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 假如崩溃了执行 handleException: ，并且传出 NSException</span></span><br><span class="line">    [[[<span class="built_in">SKUncaughtExceptionHandler</span> alloc] init] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:[<span class="built_in">NSException</span> exceptionWithName:[exception name] reason:[exception reason]</span><br><span class="line">      userInfo:userInfo]</span><br><span class="line">     waitUntilDone:<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SignalExceptionHandler(<span class="type">int</span> signal) &#123;</span><br><span class="line">    <span class="comment">// 全局计数器</span></span><br><span class="line">    int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);</span><br><span class="line">    <span class="keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录Signal</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *userInfo =</span><br><span class="line">    [<span class="built_in">NSMutableDictionary</span></span><br><span class="line">     dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithInt:signal]</span><br><span class="line">     forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class="line">    <span class="comment">// 获取堆栈信息数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *callStack = [UncaughtExceptionHandler backtrace];</span><br><span class="line">    <span class="comment">// 写入地址</span></span><br><span class="line">    [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];</span><br><span class="line">    <span class="comment">// 假如崩溃了执行 handleException: ，并且传出 NSException</span></span><br><span class="line">    [[[<span class="built_in">SKUncaughtExceptionHandler</span> alloc] init] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:[<span class="built_in">NSException</span> exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason: [<span class="built_in">NSString</span> stringWithFormat:</span><br><span class="line">       <span class="built_in">NSLocalizedString</span>(<span class="string">@&quot;Signal %d was raised.&quot;</span>, <span class="literal">nil</span>),signal] userInfo:[<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey]] waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)backtrace &#123;</span><br><span class="line">    <span class="type">void</span>* callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//  该函数用来获取当前线程调用堆栈的信息,获取的信息将会被存放在buffer中(callstack),它是一个指针数组。</span></span><br><span class="line">    <span class="type">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">//  backtrace_symbols将从backtrace函数获取的信息转化为一个字符串数组.</span></span><br><span class="line">    <span class="type">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">         <span class="type">int</span> i = UncaughtExceptionHandlerSkipAddressCount;</span><br><span class="line">         i &lt; UncaughtExceptionHandlerSkipAddressCount + UncaughtExceptionHandlerReportAddressCount;</span><br><span class="line">         i++)</span><br><span class="line">    &#123;</span><br><span class="line">        [backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs); <span class="comment">// 记得释放</span></span><br><span class="line">    <span class="keyword">return</span> backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)handleException:(<span class="built_in">NSException</span> *)exception &#123;</span><br><span class="line">    <span class="comment">// 打印或弹出框</span></span><br><span class="line">		<span class="comment">// 此处省略</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建自己的Runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFArrayRef</span> allModes = <span class="built_in">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class="line">    <span class="keyword">while</span> (!dismissed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)allModes) &#123;</span><br><span class="line">         		<span class="comment">// 快速切换mode</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(allModes);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注销NSException和Signal</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    	signal([signals[index] intValue], SIG_DFL);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">    <span class="comment">// 杀死 或 唤起</span></span><br><span class="line">    <span class="keyword">if</span> ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) &#123;</span><br><span class="line">        kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Crash-定位"><a href="#Crash-定位" class="headerlink" title="Crash 定位"></a>Crash 定位</h3><p>前面我们已经将Crash的上报工作做完了，也就是解决了第一个问题: <strong>发现问题</strong>。问题既然被发现，那么就必须要被解决，一个Crash如何保证得到处理，需要准确地对Crash行为进行复现，也就是回到案发现场，场景再现。</p>
<p>有些Crash比较容易复现，比如UI操作类、数组越界等，只要定位到具体的类，很快就能复现出崩溃，这种问题就比较好解决，我们称之为<strong>可稳定复现</strong>。既然有可以稳定复现的Crash，相对的也存在不那么稳定复现的Crash，它需要特定的条件才得以触发。比如同样的数据，在32位机器下的某个操作场景下就会Crash，而在64位机器下就无事发生，像这种问题我们就称为<strong>不稳定复现</strong>。</p>
<p>像上述提到的两种问题，还都属于<strong>可复现</strong>的范畴内，通过排查各种客观因素，还是有很大概率能够复现出来的，这些都算不上定位上的难点。而真正难以复现的问题，往往是使用者无法直接感知到原因的，它可能在A页面发生闪退，重启后A没事了缺又在B页面闪退，令人头疼不已。这类问题往往都发生在内存上，最臭名昭著的就是<strong>野指针</strong>，像这种<strong>极难复现</strong>的问题，它需要工程师花费大量的时间和精力去排查，着手分析，不仅解决效率极低，且难以稳定暴露，最痛苦的是它往往就是你CrashList里出现频率最高的问题，那么有没有办法可以治它呢，答案是：有。</p>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><blockquote>
<p><strong>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称野指针。</strong></p>
</blockquote>
<p>为什么线上的野指针问题层出不穷，我们在测试阶段都干嘛了？按理说测试阶段该跑的case都跑了，如果有问题早就有了，为什么就没有被发现呢？这个问题还真问题对了，它往往就是没有在测试阶段被发现，它的出现有太多的不确定性，不是依靠简单的提高测试覆盖率就能解决的。即使你跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致Crash</p>
<h5 id="为什么不必现"><a href="#为什么不必现" class="headerlink" title="为什么不必现"></a>为什么不必现</h5><p>野指针是指，指向一个<code>已删除</code>的对象或未申请<code>访问受限</code>的内存的指针。我们这里主要说的是objc对象释放后指针未置空所导致的野指针。</p>
<p>既然是访问已经释放的对象为什么不是必现呢？</p>
<p>这是 iOS 内存管理方式所造成的，当析构执行（dealloc）后，只是告诉系统，这片内存我不用了，而系统并没有就让这片内存真的不能访问。</p>
<p>比如说下面这几种场景</p>
<ul>
<li><p>对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。</p>
</li>
<li><p>对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）。</p>
</li>
<li><p>对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。</p>
</li>
</ul>
<h5 id="野指针定位"><a href="#野指针定位" class="headerlink" title="野指针定位"></a>野指针定位</h5><p>目前有两种主要的方法来进行野指针定位</p>
<ul>
<li>通过<code>free函数</code>来进行野指针定位</li>
<li>通过<code>dealloc</code>函数来进行野指针定位</li>
</ul>
<h6 id="通过free函数"><a href="#通过free函数" class="headerlink" title="通过free函数"></a>通过free函数</h6><p>通过<code>fishhook</code>替换C函数的free方法为自身方法safe_free，就类似runtime方法交换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> init_safe_free() &#123;</span><br><span class="line">    _unfreeQueue = ds_queue_create(MAX_STEAL_MEM_NUM);</span><br><span class="line">    orig_free = (<span class="type">void</span>(*)(<span class="type">void</span>*))dlsym(RTLD_DEFAULT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    rebind_symbols((<span class="keyword">struct</span> rebinding[])&#123;&#123;<span class="string">&quot;free&quot;</span>, (<span class="type">void</span>*)safe_free&#125;&#125;, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>safe_free</code>方法中对<code>已经释放变量</code>的内存，填充<code>0x55</code>，使已经释放变量不能访问，从而使某些野指针从不必现Crash变成了必现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> safe_free(<span class="type">void</span> *p) &#123;</span><br><span class="line">    size_tmemSiziee = malloc_size(p);</span><br><span class="line">    memset(p,<span class="number">0x55</span>, memSiziee);</span><br><span class="line">    orig_free(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里之所以填充为<code>0x55</code>是因为Xcode的僵尸对象（ Zombie Object）填充的就是<code>0x55</code>。<br> 如果填充为像<code>0x22</code>这样的数据也是可以，因为之前这里是存储的是一个对象，这个对象被数据覆盖了，当你调用方法的时候，数据无法响应<code>对应的方法</code>，因此也会导致崩溃。</p>
<p>但是由于填充了0x55的内存地址很可能被新的数据内容填充，使得野指针的crash又变得不必现。</p>
<p>例如下面这种情况:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *testObj = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="comment">// 这里的testObj指向的内存空间的内容被填充为0x55，然后调用free真正释放了，这块内存空间被系统回收利用，但testObj仍然指向这块内存空间</span></span><br><span class="line">[testObj release];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 紧接着新生成的UIView很快的就会覆盖了testObj指向的内存空间，这时候testObj指向的仍然还是一个UIView对象</span></span><br><span class="line">  <span class="built_in">UIView</span>* testView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">200</span>,<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.view.bounds), <span class="number">60</span>)];</span><br><span class="line">  [<span class="keyword">self</span>.view addSubview:testView];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时候调用UIView的实例方法setNeedsLayout方法完全不会发生Crash</span></span><br><span class="line">[testObj setNeedsLayout];</span><br></pre></td></tr></table></figure>

<p>没有发生Crash可不是好事，因为这种情况如果后续再Crash，问题就非常难查，因为你看到的Crash栈很可能和出错的代码完全没有关联。既然这个问题这么棘手，最好还是和之前一样，让这个Crash提前暴露。</p>
<p>为了防止上面这种情况，我们干脆就不释放这片内存了。也就是当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> DSQueue* _unfreeQueue = <span class="literal">NULL</span>;<span class="comment">//用来保存自己偷偷保留的内存:1这个队列要线程安全或者自己加锁;2这个队列内部应该尽量少申请和释放堆内存。</span></span><br><span class="line"><span class="type">int</span> unfreeSize = <span class="number">0</span>;<span class="comment">//用来记录我们偷偷保存的内存的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STEAL_MEM_SIZE 1024*1024*100<span class="comment">//最多存这么多内存，大于这个值就释放一部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STEAL_MEM_NUM 1024*1024*10<span class="comment">//最多保留这么多个指针，再多就释放一部分</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BATCH_FREE_NUM 100<span class="comment">//每次释放的时候释放指针数量</span></span></span><br></pre></td></tr></table></figure>

<p>为了防止系统内存过快耗尽，我们需要在自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。同时在系统内存警告的时候，也要释放一部分内存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统内存警告的时候调用这个函数释放一些内存</span></span><br><span class="line"><span class="type">void</span> free_some_mem(size_t freeNum)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    size_t count = ds_queue_length(_unfreeQueue);</span><br><span class="line">    freeNum= freeNum &gt; count ? count:freeNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;freeNum; i++) &#123;</span><br><span class="line">        <span class="type">void</span> *unfreePoint = ds_queue_get(_unfreeQueue);</span><br><span class="line">        size_t memSiziee = malloc_size(unfreePoint);</span><br><span class="line">        __sync_fetch_and_sub(&amp;unfreeSize, memSiziee);</span><br><span class="line">        orig_free(unfreePoint);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果只是对已经释放的对象内存空间填充为0x55,这样发生Crash的时候，我们得到的崩溃信息非常有限，但对于崩溃信息，我们肯定希望知道更具体一点:比如是哪个类，调了什么方法，对象的地址之类。</p>
<p>为了解决上述的问题，我们需要引入一个继承自NSProxy的代理类，同时它持有一个originClass，重写消息转发的三个方法以及NSObject的实例方法，来进行异常信息的打印。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)respondsToSelector: (SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.originClass instancesRespondToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector: (SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.originClass instanceMethodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation: (<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> _throwMessageSentExceptionWithSelector: invocation.selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Private</span></span><br><span class="line">- (<span class="type">void</span>)_throwMessageSentExceptionWithSelector: (SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;(-[%@ %@]) was sent to a zombie object at address: %p&quot;</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.originClass), <span class="built_in">NSStringFromSelector</span>(selector), <span class="keyword">self</span>] userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为NSProxy只能作为Objc对象的代理，所以safe_free函数需要添加判断。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> safe_free(<span class="type">void</span>* p)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> unFreeCount = ds_queue_length(_unfreeQueue);</span><br><span class="line">    <span class="comment">// 保留的内存大于一定值的时候就释放一部分</span></span><br><span class="line">    <span class="keyword">if</span> (unFreeCount &gt; MAX_STEAL_MEM_NUM*<span class="number">0.9</span> || unfreeSize&gt;MAX_STEAL_MEM_SIZE) &#123;</span><br><span class="line">        free_some_mem(BATCH_FREE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size_t memSiziee = malloc_size(p);</span><br><span class="line">        <span class="keyword">if</span> (memSiziee &gt; sYHCatchSize) &#123;<span class="comment">//有足够的空间才覆盖</span></span><br><span class="line">            <span class="type">id</span> obj=(<span class="type">id</span>)p;</span><br><span class="line">            Class origClass= object_getClass(obj);</span><br><span class="line">            <span class="comment">// 判断是不是objc对象</span></span><br><span class="line">            <span class="type">char</span> *type = <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(obj));</span><br><span class="line">            <span class="keyword">if</span> (strcmp(<span class="string">&quot;@&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">                memset(obj, <span class="number">0x55</span>, memSiziee);</span><br><span class="line">                memcpy(obj, &amp;sYHCatchIsa, <span class="keyword">sizeof</span>(<span class="type">void</span>*));<span class="comment">//把我们自己的类的isa复制过去</span></span><br><span class="line">                </span><br><span class="line">                object_setClass(obj, [MOACatcher <span class="keyword">class</span>]);</span><br><span class="line">                ((MOACatcher *)obj).originClass = origClass;</span><br><span class="line">                __sync_fetch_and_add(&amp;unfreeSize,(<span class="type">int</span>)memSiziee);<span class="comment">//多线程下int的原子加操作,多线程对全局变量进行自加，不用理线程锁了</span></span><br><span class="line">                ds_queue_put(_unfreeQueue, p);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               orig_free(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           orig_free(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="通过dealloc函数"><a href="#通过dealloc函数" class="headerlink" title="通过dealloc函数"></a>通过dealloc函数</h6><p>通过objc的runtime方法进行方法交换，交换了根类的NSObject和NSProxy的dealloc方法为originalDeallocImp。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *deallocImps = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (Class rootClass <span class="keyword">in</span> _rootClasses) &#123;</span><br><span class="line">    IMP originalDeallocImp = __lxd_swizzleMethodWithBlock(class_getInstanceMethod(rootClass, <span class="keyword">@selector</span>(dealloc)), swizzledDeallocBlock);</span><br><span class="line">    [deallocImps setObject: [<span class="built_in">NSValue</span> valueWithBytes: &amp;originalDeallocImp objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(IMP))] forKey: <span class="built_in">NSStringFromClass</span>(rootClass)];</span><br><span class="line">&#125;</span><br><span class="line">_rootClassDeallocImps = [deallocImps <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure>

<p>为了避免 内存空间释放之后被复写造成野指针问题，通过字典_rootClassDeallocImps存储被释放的对象，同时设置在30秒之后调用dealloc方法将存储的对象释放，避免内存空间的增大。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      swizzledDeallocBlock = [^<span class="type">void</span>(<span class="type">id</span> obj) &#123;</span><br><span class="line">          Class currentClass = [obj <span class="keyword">class</span>];</span><br><span class="line">          <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(currentClass);</span><br><span class="line">          <span class="keyword">if</span> ([__lxd_sniff_white_list() containsObject: clsName]) &#123;</span><br><span class="line">              __lxd_dealloc(obj);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">NSValue</span> *objVal = [<span class="built_in">NSValue</span> valueWithBytes: &amp;obj objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(obj))];</span><br><span class="line">              object_setClass(obj, [LXDZombieProxy <span class="keyword">class</span>]);</span><br><span class="line">              ((LXDZombieProxy *)obj).originClass = currentClass;</span><br><span class="line"></span><br><span class="line">              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">30</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                  __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> deallocObj = <span class="literal">nil</span>;</span><br><span class="line">                  [objVal getValue: &amp;deallocObj];</span><br><span class="line">                  object_setClass(deallocObj, currentClass);</span><br><span class="line">                  __lxd_dealloc(deallocObj);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">copy</span>];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>也同样为了获取更多的崩溃信息采用了继承自NSProxy类的代理类的来进行消息转发，重写消息转发方法以及内存管理相关的方法。</p>
<p>因为objc内部还有一些底层的类，这些类我们项目中一般不涉及，因此不会是这些类造成野指针，就可以通过白名单的机制，放弃对这些类的dealloc方法的捕获。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSMutableSet</span> *__lxd_sniff_white_list() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *lxd_sniff_white_list;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        lxd_sniff_white_list = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> lxd_sniff_white_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>free函数</code>来进行野指针定位</p>
<ul>
<li><strong>优点:</strong> 覆盖范围广，覆盖了objc、C++、C函数，对于iOS项目适用于混编的工程。</li>
<li><strong>缺点:</strong> 想要获得具体的<code>崩溃信息</code>，还是需要进行objc对象的判断，同时<code>free函数</code>的覆盖范围广，也会造成一定性能的损耗，毕竟我们在<code>safe_free</code>中添加了一些判断。</li>
</ul>
<p>通过<code>dealloc</code>函数来进行<code>野指针</code>定位</p>
<ul>
<li><strong>优点:</strong> 针对objc语言，利用objc的<code>方法交换</code>、<code>消息转发</code>等特性，对于iOS 项目来说更具有<code>针对性</code>和<code>可扩展性</code>。</li>
<li><strong>缺点:</strong> 相对作用范围较小</li>
</ul>
<h3 id="Crash-防护"><a href="#Crash-防护" class="headerlink" title="Crash 防护"></a>Crash 防护</h3><p>在这个阶段需要做的事情主要就是<strong>问题修复</strong>和<strong>防止再次发生</strong>了，我们会列举几种 iOS 中常见的崩溃场景，并给出解决方案和相应的防护措施。</p>
<h4 id="找不到方法的实现unrecognized-selector-sent-to-instance"><a href="#找不到方法的实现unrecognized-selector-sent-to-instance" class="headerlink" title="找不到方法的实现unrecognized selector sent to instance"></a>找不到方法的实现unrecognized selector sent to instance</h4><p><strong>常见场景</strong>：</p>
<ul>
<li>没有实现代理</li>
<li>可变属性使用copy修饰</li>
<li>低版本系统使用高版本API</li>
</ul>
<p><strong>原因</strong>：由于找不到方法 iOS 系统抛出异常导致崩溃。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p>尽量避免使用<code>performSelector</code>一系列方法</p>
</li>
<li><p><code>delegate</code> 方法调用前进行 <code>respondsToSelector</code> 判断，或者Release模式下使用<a target="_blank" rel="noopener" href="https://github.com/forkingdog/ProtocolKit">ProtocolKit</a>给协议添加默认实现防止崩溃，Debug模式下关闭默认实现</p>
</li>
<li><p>使用<code>高版本的系统方法</code>的时候做判断</p>
</li>
<li><p>可变属性（如<code>NSMutableArray</code>），不要使用<code>copy</code>修饰，或者重写<code>set</code>方法，我们也可以通过 LLVM &amp; Clang 编写 Xcode 插件来及时提醒工程师对修饰符的使用</p>
<img src="/image/xcode-plugin.png" style="zoom:50%">
</li>
<li><p>没有实现代理，可以给 NSObject 添加一个分类，实现<code>消息转发</code>的几个方法，以此来规避 Crash 行为。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="comment">// 已实现不做处理</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;在 %@ 类中, 调用了没有实现的实例方法: %@ &quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]), <span class="built_in">NSStringFromSelector</span>(anInvocation.selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector]) &#123;</span><br><span class="line">        <span class="comment">// 已实现不做处理</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;在 %@ 类中, 调用了没有实现的类方法: %@ &quot;</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]), <span class="built_in">NSStringFromSelector</span>(anInvocation.selector));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="KVC造成的crash"><a href="#KVC造成的crash" class="headerlink" title="KVC造成的crash"></a>KVC造成的crash</h4><p><strong>常见场景</strong>：</p>
<ul>
<li>对象不支持KVC</li>
<li>key为nil</li>
<li>key不是object的属性产生的crash</li>
</ul>
<p><strong>原因</strong>：给不存在的key（包括key为nil）设置value</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p>如果属性存在，利用iOS的反射机制来规避，<code>NSStringFromSelector(@selector())</code>将<code>SEL</code>反射为字符串作为key。这样在<code>@selector()</code>中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告</p>
</li>
<li><p>重写类的<code>setValue:forUndefinedKey:</code>和<code>valueForUndefinedKey:</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="type">void</span>)setValue:(<span class="type">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="type">id</span>)valueForUndefinedKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="EXC-BAD-ACCESS"><a href="#EXC-BAD-ACCESS" class="headerlink" title="EXC_BAD_ACCESS"></a>EXC_BAD_ACCESS</h4><p><strong>常见场景</strong>：</p>
<p>基本都是悬垂指针&#x2F;野指针问题</p>
<ul>
<li>访问没有实现的blcok</li>
<li>对象没有被初始化</li>
<li>访问的对象已经被释放掉<ul>
<li>循环引用引起的内存泄露</li>
<li>unsafe_unretained修饰的对象释放后，不会自动置nil，变成野指针</li>
<li>应该使用strong&#x2F;weak修饰的对象，却错误的使用assign修饰，释放后不会自动置nil，导致崩溃</li>
<li>给类添加添加关联变量的时候，类似上面的场景，应该使用OBJC_ASSOCIATION_RETAIN_NONATOMIC修饰，却错误使用OBJC_ASSOCIATION_ASSIGN</li>
</ul>
</li>
</ul>
<p><strong>原因</strong>：出现悬垂指针，对象没有被初始化，或者访问的对象被释放</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><p><code>Debug</code>阶段开启僵尸模式，<code>Release</code>时关闭僵尸模式</p>
</li>
<li><p>使用Xcode的<code>Address Sanitizer</code>检查地址访问越界</p>
</li>
<li><p>创建对象的时候记得初始化</p>
</li>
<li><p>对象的属性使用正确的修饰方式</p>
</li>
<li><p>调用<code>block</code>的时候，须做判断</p>
</li>
<li><p>造成内存泄露常见的原因是在闭包中造成了循环引用，在objc中我们需要注意闭包内外的weak-strong关系，而在Swift中，我们可以设计一个安全闭包来避免循环引用问题</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Delegated</span>&lt;<span class="type">Input</span>, <span class="type">Output</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> callback: ((<span class="type">Input</span>) -&gt; <span class="type">Output</span>?)<span class="operator">?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">delegate</span>&lt;<span class="type">Target</span> : <span class="type">AnyObject</span>&gt;(<span class="params">to</span> <span class="params">target</span>: <span class="type">Target</span>,</span><br><span class="line">                                                      <span class="params">with</span> <span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">Target</span>, <span class="type">Input</span>) -&gt; <span class="type">Output</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.callback <span class="operator">=</span> &#123; [<span class="keyword">weak</span> target] input <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> target <span class="operator">=</span> target <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> callback(target, input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">call</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Input</span>) -&gt; <span class="type">Output</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.callback<span class="operator">?</span>(input)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isDelegateSet: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> callback <span class="operator">!=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Delegated</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">stronglyDelegate</span>&lt;<span class="type">Target</span> : <span class="type">AnyObject</span>&gt;(<span class="params">to</span> <span class="params">target</span>: <span class="type">Target</span>,</span><br><span class="line">                                                              <span class="params">with</span> <span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">Target</span>, <span class="type">Input</span>) -&gt; <span class="type">Output</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.callback <span class="operator">=</span> &#123; input <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> callback(target, input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">manuallyDelegate</span>(<span class="params">with</span> <span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">Input</span>) -&gt; <span class="type">Output</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.callback <span class="operator">=</span> callback</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">removeDelegate</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.callback <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Delegated</span> <span class="keyword">where</span> <span class="type">Input</span> <span class="operator">==</span> <span class="type">Void</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">delegate</span>&lt;<span class="type">Target</span> : <span class="type">AnyObject</span>&gt;(<span class="params">to</span> <span class="params">target</span>: <span class="type">Target</span>,</span><br><span class="line">                                                      <span class="params">with</span> <span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">Target</span>) -&gt; <span class="type">Output</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate(to: target, with: &#123; target, voidInput <span class="keyword">in</span> callback(target) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">stronglyDelegate</span>&lt;<span class="type">Target</span> : <span class="type">AnyObject</span>&gt;(<span class="params">to</span> <span class="params">target</span>: <span class="type">Target</span>,</span><br><span class="line">                                                              <span class="params">with</span> <span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">Target</span>) -&gt; <span class="type">Output</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stronglyDelegate(to: target, with: &#123; target, voidInput <span class="keyword">in</span> callback(target) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Delegated</span> <span class="keyword">where</span> <span class="type">Input</span> <span class="operator">==</span> <span class="type">Void</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">call</span>() -&gt; <span class="type">Output</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.call(())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Delegated</span> <span class="keyword">where</span> <span class="type">Output</span> <span class="operator">==</span> <span class="type">Void</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">call</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Input</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.callback<span class="operator">?</span>(input)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Delegated</span> <span class="keyword">where</span> <span class="type">Input</span> <span class="operator">==</span> <span class="type">Void</span>, <span class="type">Output</span> <span class="operator">==</span> <span class="type">Void</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">call</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.call(())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">self</span>.downloader <span class="operator">=</span> <span class="type">ImageDownloader</span>()</span><br><span class="line">downloader.didDownload <span class="operator">=</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    strongSelf.currentImage <span class="operator">=</span> image</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">self</span>.downloader <span class="operator">=</span> <span class="type">ImageDownloader</span>()</span><br><span class="line">downloader.didDownload.delegate(to: <span class="keyword">self</span>) &#123; (<span class="keyword">self</span>, image) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.currentImage <span class="operator">=</span> image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="KVO引起的崩溃"><a href="#KVO引起的崩溃" class="headerlink" title="KVO引起的崩溃"></a>KVO引起的崩溃</h4><p><strong>常见场景</strong>：</p>
<ul>
<li>观察者&#x2F;被观察者是局部变量，会崩溃</li>
<li>没有实现observeValueForKeyPath:ofObject:changecontext:方法:，会崩溃</li>
<li>重复移除观察者，会崩溃</li>
</ul>
<p><strong>原因</strong>：添加了观察者，没有在正确的时机移除；以及没有实现相应的监听方法</p>
<p><strong>解决方案</strong>:</p>
<ul>
<li>addObserver和removeObserver一定要成对出现</li>
<li>保证observeValueForKeyPath:ofObject:changecontext:的实现</li>
</ul>
<h4 id="集合类相关崩溃"><a href="#集合类相关崩溃" class="headerlink" title="集合类相关崩溃"></a>集合类相关崩溃</h4><p><strong>常见场景</strong>：</p>
<ul>
<li>数组越界</li>
<li>向数组中添加nil元素</li>
<li>数组遍历的时候使用错误的方式移除元素</li>
<li>使用setObject:forKey:向字典中添加value为nil的键值对</li>
</ul>
<p><strong>原因</strong>：越界、添加nil、多线程非原子性操作、遍历的同时移除元素</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>给集合类添加<code>category</code>重写原来的方法，在内部做判断</li>
<li>使用<code>Runtime</code>把原来的方法替换成自定义的安全方法</li>
<li>给<code>NSMutableDictionary</code>添加元素的时候，使用<code>setObject:forKey:</code>向字典中添加value为nil的键值对，推荐使用KVC的<code>setValue:nil forKey:</code>。<code>[mutableDictionary setValue:nil ForKey:@&quot;name&quot;]</code>不会崩溃，只是从字典中移除name键值对</li>
<li>因为<code>NSMutableArray、NSMutableDictionary</code>不是线程安全的，所以在多线程环境下要保证读写操作的原子性，使用 <strong>加锁</strong> 、<strong>信号量</strong> 、<strong>GCD串行队列</strong> 、<strong>GCD栅栏</strong><code>dispatch_barrier_async</code>、<strong>CGD组</strong>的<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code></li>
</ul>
<h4 id="多线程中的崩溃"><a href="#多线程中的崩溃" class="headerlink" title="多线程中的崩溃"></a>多线程中的崩溃</h4><p><strong>常见场景</strong>：</p>
<ul>
<li>dispatch_group_leave比dispatch_group_enter执行的次数多</li>
<li>在子线程更新UI</li>
<li>多个线程同时释放一个对象（多线程下非线程安全类的使用）</li>
<li>多线程中的数组扩容、浅复制<ul>
<li>扩容：数组的地址已经改变，报错was mutated <strong>while</strong> being enumerated</li>
<li>浅复制：访问僵尸对象，报错EXC_BAD_ACCESS</li>
</ul>
</li>
</ul>
<p><strong>原因</strong>：死锁、子线程中更新UI、多个线程同时释放一个对象</p>
<p><strong>解决方案</strong>：多线程遇到需要同步的时候，加锁，添加信号量等进行同步操作。一般多线程发生的Crash，会收到SIGSEGV信号，表明试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据。</p>
<h4 id="Socket长连接导致的崩溃"><a href="#Socket长连接导致的崩溃" class="headerlink" title="Socket长连接导致的崩溃"></a>Socket长连接导致的崩溃</h4><p><strong>常见场景</strong>：长连接socket或重定向管道进入后台，没有关闭导致崩溃</p>
<p><strong>原因</strong>：当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。而根据信号的默认处理规则，SIGPIPE信号的默认执行动作是terminate(终止、退出),所以client会退出。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>切换到后台时，关闭长连接和管道，回到前台重新创建</li>
<li>使用signal(SIGPIPE, SIG_IGN)，将SIGPIP交给系统处理，这么做将SIGPIPE设为SIG_IGN，使客户端不执行默认操作，即不退出</li>
</ul>
<h4 id="Watch-Dog超时造成的崩溃"><a href="#Watch-Dog超时造成的崩溃" class="headerlink" title="Watch Dog超时造成的崩溃"></a>Watch Dog超时造成的崩溃</h4><p><strong>常见场景</strong>：应用启动阶段用时过长造成崩溃</p>
<p><strong>原因</strong>：这是由于触发了看门狗（Watch Dog）机制造成的，通常是应用花费太多的时间无法启动、终止或者响应系统事件，一般异常编码是0x8badf00d，表示应用发生watch dog超时而被iOS终止。在不同的生命周期，触发看门狗机制的超时时间有所不同：</p>
<img src="/image/watchdog-timeout.png" style="zoom:50%">

<p><strong>解决方案</strong>：主线程只负责更新UI和事件响应，将耗时操作（网络请求、数据库读写等）异步放到后台线程执行。</p>
<h4 id="服务器返回NSNull导致的崩溃"><a href="#服务器返回NSNull导致的崩溃" class="headerlink" title="服务器返回NSNull导致的崩溃"></a>服务器返回NSNull导致的崩溃</h4><p><strong>常见场景</strong>：多见于Java做后台服务器开发语言</p>
<p><strong>原因</strong>：NSNull用于objc对象的占位，一般会作为集合中的占位元素，给NSNull对象发送消息会crash的</p>
<p><strong>解决方案</strong>：利用消息转发。参考：<a target="_blank" rel="noopener" href="https://github.com/nicklockwood/NullSafe">NullSafe</a>。当我们给一个NSNull对象发送消息的话，可能会崩溃（null是有内存的），而发送给nil的话，是不会崩溃的。</p>
<h4 id="某些32位机型才会出现的崩溃"><a href="#某些32位机型才会出现的崩溃" class="headerlink" title="某些32位机型才会出现的崩溃"></a>某些32位机型才会出现的崩溃</h4><p><strong>常见场景</strong>：在32位机型上使用NSNumber时，由于修饰符使用不当可能会造成Crash</p>
<p><strong>原因</strong>：ARC模式下系统在32位设备上对<code>NSNumber</code>类型的对象做的优化不够彻底，只对-1～12这少数的几个数做了优化，在该范围内创建的实例对象存储在<code>内存共享区</code>，永远不会被销毁。而只要大于12或小于-1就是正常的创建在堆上的对象，系统根据引用计数管理对象是否回收。如果此时恰好使用了错误的修饰符（如assgin），导致对象可能被提前释放，就会引发Crash</p>
<p><strong>解决方案</strong>：NSNumber 一律采用 strong 修饰</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后感谢头条的<a target="_blank" rel="noopener" href="https://junyixie.github.io/">谢俊逸</a>同学对软件异常转换信号方面疑惑的解答！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://www.cocoawithlove.com/2010/05/handling-unhandled-exceptions-and.html">Handling unhandled exceptions and signals</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs/identifying_the_cause_of_common_crashes/addressing_watchdog_terminations">Addressing Watchdog Terminations</a></p>
<p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://developer.apple.com/library/mac/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC">Apple Kernel Programming Guide</a></p>
<p><a target="_blank" rel="noopener" href="https://toutiao.io/posts/ziqho/preview">漫谈 iOS Crash 收集框架</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/725e7d69272c">浅谈Mach Exceptions</a></p>
<p><a target="_blank" rel="noopener" href="https://junyixie.github.io/2019/09/28/CrashMonitorSystem/">崩溃捕获系统的原理（一）异常信号</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/04f822f929f0">iOS Mach 异常、Unix 信号 和NSException 异常</a></p>
<p><a target="_blank" rel="noopener" href="https://satanwoo.github.io/2017/10/18/abort/">iOS内存abort(Jetsam) 原理探究</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38633659/article/details/82496635">iOS开发：Crash异常总结与捕获</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9fd4dc046046">iOS 野指针定位:野指针嗅探器</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903748435705864#heading-21">LLVM &amp; Clang 入门</a></p>
<p>《Mac OS X and iOS Internals：To the Apple’s Core》</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/interview-dispatch-once/" title="dispatch_once 为什么可以保证只执行一次？">dispatch_once 为什么可以保证只执行一次？</a></h2>
                <p class="excerpt">
                
                想尝试写一个面试回答的系列，这是第一篇。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-05-08T06:12:02.000Z" class="post-list__meta--date date">2020-05-08</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/GCD/" rel="tag">GCD</a>, <a class="-none-link" href="/tags/dispatch-once/" rel="tag">dispatch_once</a>, <a class="-none-link" href="/tags/iOS/" rel="tag">iOS</a>
</span><a class="btn-border-small" href="/interview-dispatch-once/">开始阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/use-navicat-premium-for-mac/" title="Navicat Premium For Mac 备份与恢复数据库">Navicat Premium For Mac 备份与恢复数据库</a></h2>
                <p class="excerpt">
                
                在 macOS 系统上使用 Navicat Premium 对服务器上的数据库进行本地备份，以及数据库丢失后的恢复。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-01-10T06:59:03.000Z" class="post-list__meta--date date">2020-01-10</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/MariaDB/" rel="tag">MariaDB</a>, <a class="-none-link" href="/tags/MySQL/" rel="tag">MySQL</a>, <a class="-none-link" href="/tags/NavicatPremium/" rel="tag">NavicatPremium</a>, <a class="-none-link" href="/tags/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/" rel="tag">折腾日记</a>, <a class="-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/" rel="tag">数据库备份</a>
</span><a class="btn-border-small" href="/use-navicat-premium-for-mac/">开始阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'warpdrive'; 
      
  var disqus_identifier = '/ios-crashprotection/';
  var disqus_title = '浅谈 iOS 中的 Crash 捕获与防护';
  var disqus_url = 'http://shevakuilin.com/ios-crashprotection/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a target="_blank" rel="noopener" href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2025 ShevaKuilin - 跃迁引擎 <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"> 渝ICP备 19012091</a>, 本站点采用 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> 搭建，使用 <a target="_blank" rel="noopener" href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a target="_blank" rel="noopener" href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
