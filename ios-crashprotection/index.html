<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="iOS Research &amp; Development">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎">
    <meta name="twitter:description" content="iOS Research &amp; Development">

    <meta property="og:type" content="article">
    <meta property="og:title" content="浅谈 iOS 中的 Crash 捕获与防护 | 跃迁引擎">
    <meta property="og:description" content="iOS Research &amp; Development">

    
    <meta name="author" content="ShevaKuilin">
    
    
<link rel="stylesheet" href="/css/vno.css">

    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">


    
    <link rel="icon" href="/images/favicon.png">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://shevakuilin.com/ios-crashprotection/"/>

                 
</head>

<body class="home-template no-js">
    
<script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>

    
<script src="/js/main.js"></script>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 跃迁引擎 的主页"><img src="/images/avatar.jpeg" width="80" alt="跃迁引擎 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 跃迁引擎">跃迁引擎</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">空気を読んだ雨降らないでよ</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">iOS Research & Development</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">主页</a></li>
            
              <li class="navigation__item"><a href="/archives">所有文章</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/shevakuilin" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-disabled"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2020-05-01T05:25:25.000Z" class="post-list__meta--date date">2020-05-01</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="-none-link" href="/tags/Crash/" rel="tag">Crash</a>, <a class="-none-link" href="/tags/iOS/" rel="tag">iOS</a>
 </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">浅谈 iOS 中的 Crash 捕获与防护</h1>
  </header>

  <section class="post">
    <p>五一假期的第一天，闲来无事，今天来聊一聊 iOS 中的 Crash 捕获与防护。<a id="more"></a></p>
<img src="https://github.com/shevakuilin/GhostPostsImages/raw/master/63238926_p0_master1200.jpg">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工程师们苦 Crash 久矣，尤其是用户感知最为明显的客户端。那居高不下的崩溃率、数不胜数的用户反馈、迟迟无法完成的 KPI，折磨着每一位客户端的开发同学。</p>
<blockquote>
<p>加断点再Debug，堆栈瞬间就爆炸，日志输出如雨下，看到异常就害怕；调试一夜没人陪，心想这锅该归谁？回想当初心后悔，不该重构这地雷；翻日志查半天，博客看了千百遍，低头又点一根烟，闪退还是没复现。</p>
</blockquote>
<p>上面这段文字很形象的描述了一位深夜排查闪退问题的工程师。那么 Crash 为何如此难以解决且反复发作，它究竟难在哪里，从客户端工程诞生至今一直困扰着无数的工程师。</p>
<h2 id="主动出击"><a href="#主动出击" class="headerlink" title="主动出击"></a>主动出击</h2><blockquote>
<p>进攻是最好的防守。</p>
</blockquote>
<p>在工作中，你不能总是守株待兔，期待 Crash 自己找上门来，主动躺在你的 Todolist 里。你需要在问题大面积爆发前，提前感知，迅速解决，就像碟中谍里的汤姆斯·布鲁克，在悄然无息间拯救地球，深藏功与名。</p>
<p>我们需要一套 Crash 主动防护机制，来帮助工程师们快速处理这些问题。</p>
<p>防护的核心是定位，定位问题的前提是能够发现问题，首先需要做的是捕获到异常然后将其上报。</p>
<h3 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h3><p>市面上能够找到的统计崩溃等异常的 SDK 非常多，友盟、Bugly、GrowingIO 等等，他们通常都是将捕获到的信息日志上传到对应的服务器上，以此来做一些后续的统计和分析。在一些规模较小的团队当中，无法面面俱到，直接引用这些 SDK 是可以接收的，但如果你的团队对应用性能有一定要求，那么这些 SDK 就会显得有些 “不够用” 了。</p>
<p>作者对市面上主流的统计 SDK 都有过较长时间的使用经验，发现无论哪一家 SDK 都有或多或少存在着两个通病：<strong>上报延迟</strong>  和 <strong>定位表述模糊</strong>。</p>
<p>我们要在用户感知之前提前发现问题，就需要在研发和提测阶段尽可能早的暴露出问题，这样一来可以在崩溃现场或第一时间捕获崩溃信息，然后将崩溃堆栈信息及时反馈给我们的工程师，也会大大提高测试和开发之前的沟通效率。</p>
<p>由于上述 SDK 存在的问题，所以这部分工作就需要我们自己来进行补充。</p>
<h3 id="Crash-捕获"><a href="#Crash-捕获" class="headerlink" title="Crash 捕获"></a>Crash 捕获</h3><p>我们需要先了解 iOS 发生崩溃的底层原理，下面是 Crash 捕获处理系统几个核心的关键领域知识。</p>
<ul>
<li>UNIX signals 信号</li>
<li>Mach Exceptions Mach异常</li>
<li>Basic Thread details 线程现场信息</li>
<li>Binary image information 动态库信息</li>
<li>Frame pointer-based stack traces 基于 fp 的 callstack 回溯</li>
<li>Compact Unwind support 辅助 callstack 回溯的 Compact Unwind 信息</li>
</ul>
<p><strong>在这里我们主要是针对 Mach异常 和 UNIX信号 的处理。</strong></p>
<h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>首先要明确几个概念及其之间的联系：<code>硬件异常</code>, <code>软件异常</code>,<code>mach异常</code>, <code>Signal异常</code>。这四种异常概念，自底向上构建了iOS系统的异常处理模型。</p>
<p>其之间的关系如下:</p>
<img src="/image/exception.png" style="zoom:50%">

<h4 id="Mach异常与Signal"><a href="#Mach异常与Signal" class="headerlink" title="Mach异常与Signal"></a>Mach异常与Signal</h4><p>iOS 中的 Crash 主要分为<code>Mach Exception</code>、<code>Singal</code>、<code>NSException</code>三种类型，每一种类型的 Crash 都处在不同的系统层级上，也有各自不同的捕获方式。</p>
<img src="/image/kernel.png" style="zoom:50%">

<h5 id="Mach-Exception"><a href="#Mach-Exception" class="headerlink" title="Mach Exception"></a>Mach Exception</h5><p>Mach是一个XNU的微内核核心，Mach异常是指最底层的内核级异常，被定义在 <code>&lt;mach/exception_types.h&gt;</code>下 。Mach异常由CPU陷阱引发，在异常发生后会被异常处理程序转换成Mach消息，接着依次投递到<code>thread</code>、<code>task</code>和<code>host</code>端口。</p>
<p>如果没有上述任何一个端口来处理这个异常并返回<code>KERN_SUCCESS</code>，那么应用将被终止。每个端口都拥有一个异常端口数组，系统暴露了后缀为<code>_set_exception_ports</code>的多个 API 让我们注册对应的异常处理到端口中，用以来捕获Mach异常，抓取Crash事件。</p>
<p>在Mach中，异常是通过内核中的主要设施<strong>消息传递机制</strong>进行处理的。一个异常与一条消息并无差别，由出错的线程或任务（通过 <code>msg_send()</code>）发送，并通过一个处理程（通过 <code>msg_recv()</code>）接收。<br> 由于Mach的异常以消息机制处理而不是通过函数调用，exception messages可以被转发到先前注册的Mach exception处理程序。这意味着你可以插入一个exception处理程序，而不干扰现有的无论是调试器或Apple’s crash reporter。可以使用<code>mach_msg() // flag MACH_SEND_MSG</code>发送原始消息到以前注册的处理程序的Mach端口，将消息转发到一个现有的处理程序。</p>
<p>综上所述，基于 mach message 机制, 可以</p>
<ul>
<li>通过注册端口监听异常消息（可以为 host, task, thread 注册异常处理端口）</li>
<li>发送异常消息</li>
</ul>
<h4 id="Mach异常与Signal的转换"><a href="#Mach异常与Signal的转换" class="headerlink" title="Mach异常与Signal的转换"></a>Mach异常与Signal的转换</h4><p>Mach异常如果不处理，默认会转化为Signal异常（所有Mach异常都默认在<code>host</code>层被<code>ux_exception</code>转换为相应的Signal，并通过<code>threadsignal</code>将信号投递到出错的线程）。如：<code>EXC_BAD_ACCESS(SIGSEGV)</code>表示的意思就是：Mach层的EXC_BAD_ACCESS异常，在host层被转换成SIGSEGV信号投递到出错的线程。<br>其中内核注册了host-level的exception handler，负责将mach异常转换为对应的Signal信号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called with kernel funnel held */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bsdinit_task(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">proc_t</span> p = current_proc();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uthread</span> *<span class="title">ut</span>;</span></span><br><span class="line">	<span class="keyword">thread_t</span> thread;</span><br><span class="line"></span><br><span class="line">	process_name(<span class="string">&quot;init&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">	ux_handler_init();</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line">	(<span class="keyword">void</span>) host_set_exception_ports(host_priv_self(),</span><br><span class="line">					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">					(<span class="keyword">mach_port_t</span>) ux_exception_port,</span><br><span class="line">					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ut = (<span class="keyword">uthread_t</span>)get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">	bsd_init_task = get_threadtask(thread);</span><br><span class="line">	init_task_failure_data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	mac_cred_label_associate_user(p-&gt;p_ucred);</span><br><span class="line">	mac_task_label_update_cred (p-&gt;p_ucred, (struct task *) p-&gt;task);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	load_init_program(p);</span><br><span class="line">	lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mach异常信号的来源，主要通过两种途径：</p>
<ul>
<li>硬件级别的触发异常</li>
<li>proc退出时会触发异常(EXC_CRASH)。</li>
</ul>
<img src="/image/exception_triage.png" style="zoom:50%">

<h4 id="Mach异常与软硬件异常"><a href="#Mach异常与软硬件异常" class="headerlink" title="Mach异常与软硬件异常"></a>Mach异常与软硬件异常</h4><h5 id="硬件异常触发流程"><a href="#硬件异常触发流程" class="headerlink" title="硬件异常触发流程"></a>硬件异常触发流程</h5><img src="/image/hardware_mach.png" style="zoom:50%">

<p>硬件异常会转化为Mach异常</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">i386_exception(</span><br><span class="line">	<span class="keyword">int</span>	exc,</span><br><span class="line">	mach_exception_code_t code,</span><br><span class="line">	mach_exception_subcode_t subcode)</span><br><span class="line">&#123;</span><br><span class="line">	mach_exception_data_type_t   codes[EXCEPTION_CODE_MAX];</span><br><span class="line"></span><br><span class="line">	DEBUG_KPRINT_SYSCALL_MACH(<span class="string">&quot;i386_exception: exc=%d code=0x%llx subcode=0x%llx\n&quot;</span>,</span><br><span class="line">							  exc, code, subcode);</span><br><span class="line">	codes[<span class="number">0</span>] = code;		<span class="comment">/* new exception interface */</span></span><br><span class="line">	codes[<span class="number">1</span>] = subcode;</span><br><span class="line">	exception_triage(exc, codes, <span class="number">2</span>);</span><br><span class="line">	<span class="comment">/*NOTREACHED*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">exception_triage(</span><br><span class="line">	exception_type_t	exception,</span><br><span class="line">	mach_exception_data_t	code,</span><br><span class="line">	mach_msg_type_number_t  codeCnt)</span><br><span class="line">&#123;</span><br><span class="line">	thread_t		thread;</span><br><span class="line">	task_t			task;</span><br><span class="line">	host_priv_t		host_priv;</span><br><span class="line">	lck_mtx_t		*mutex;</span><br><span class="line">	kern_return_t	kr;</span><br><span class="line"></span><br><span class="line">	assert(exception != EXC_RPC_ALERT);</span><br><span class="line"></span><br><span class="line">	thread = current_thread();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to raise the exception at the activation level.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex = &amp;thread-&gt;mutex;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, thread-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Maybe the task level will handle it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	task = current_task();</span><br><span class="line">	mutex = &amp;task-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, task-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * How about at the host level?</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	host_priv = host_priv_self();</span><br><span class="line">	mutex = &amp;host_priv-&gt;lock;</span><br><span class="line">	kr = exception_deliver(thread, exception, code, codeCnt, host_priv-&gt;exc_actions, mutex);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">		<span class="keyword">goto</span> <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Nobody handled it, terminate the task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	(<span class="keyword">void</span>) task_terminate(task);</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span>:</span><br><span class="line">	<span class="keyword">if</span> ((exception != EXC_CRASH) &amp;&amp; (exception != EXC_RESOURCE) &amp;&amp;</span><br><span class="line">	    (exception != EXC_GUARD))</span><br><span class="line">		thread_exception_return();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="软件异常"><a href="#软件异常" class="headerlink" title="软件异常"></a>软件异常</h5><p>处理流程如下图所示：</p>
<img src="/image/kill.png" style="zoom:50%">

<p>通过kill() 直接抛出signal异常，这里需要<strong>注意</strong>，网上有些观点认为</p>
<blockquote>
<p>因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用kill和pthread_kill)也首先沉下来被转换为Mach异常，再转换为Unix信号。</p>
<p>软件异常的处理流程：abort()-&gt; kill()/pthread_kill信号-&gt; Mach异常-&gt; Unix信号（SIGABRT）</p>
</blockquote>
<p>也就是说，软件异常与硬件异常相同，都是先转为Mach异常，再转换成的Signal。</p>
<p>但这个观点经过验证后发现是站不住脚的，如果按照此观点所说，那么我们在软件异常发生时，只实现mach exceptiona捕获，是可以抓到abort的；但如果你去试验一下会发现是抓不到abort的，这也就意味着<strong>在软件异常发生后根本就没有走mach exceptiona的流程</strong>。</p>
<p>软件产生的信号来自<code>kill()</code>、<code>pthread_kill()</code>两个函数的调用，大概过程是这样的：<code>kill()</code>/<code>pthread_kill()</code> –&gt; <code>...</code> –&gt; <code>psignal_internal()</code> –&gt; <code>act_set_astbsd()</code>。最终也会调用<code>act_set_astbsd()</code>发送信号到目标线程。</p>
<p>abort()的源码也印证了这一点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__private_extern__ <span class="keyword">void</span></span><br><span class="line">__abort()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> sigaction act;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!CRGetCrashLogMessage())</span><br><span class="line">		CRSetCrashLogMessage(<span class="string">&quot;__abort() called&quot;</span>);</span><br><span class="line">	act.sa_handler = SIG_DFL;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	(<span class="keyword">void</span>)_sigaction(SIGABRT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGABRT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* &lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread </span></span><br><span class="line"><span class="comment">	 * This helps gdb focus on the thread calling abort()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (__is_threaded) &#123;</span><br><span class="line">	    <span class="comment">/* Block all signals on all other threads */</span></span><br><span class="line">	    sigset_t fullmask;</span><br><span class="line">	    sigfillset(&amp;fullmask);</span><br><span class="line">	    (<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;fullmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* &lt;rdar://problem/8400096&gt; Set the workqueue killable */</span></span><br><span class="line">	    __pthread_workqueue_setkill(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    (<span class="keyword">void</span>)pthread_sigmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="keyword">void</span>)pthread_kill(pthread_self(), SIGABRT);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    (<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	    (<span class="keyword">void</span>)kill(getpid(), SIGABRT);</span><br><span class="line">	&#125;</span><br><span class="line">	usleep(TIMEOUT); <span class="comment">/* give time for signal to happen */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If for some reason SIGABRT was not delivered, we exit using __builtin_trap</span></span><br><span class="line"><span class="comment">	 * which generates an illegal instruction on i386: &lt;rdar://problem/8400958&gt;</span></span><br><span class="line"><span class="comment">	 * and SIGTRAP on arm.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sigfillset(&amp;act.sa_mask);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGILL);</span><br><span class="line">	sigdelset(&amp;act.sa_mask, SIGTRAP);</span><br><span class="line">	(<span class="keyword">void</span>)_sigprocmask(SIG_SETMASK, &amp;act.sa_mask, <span class="literal">NULL</span>);</span><br><span class="line">	__builtin_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在abort()源码注释着：<code>&lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread</code> , 它是这样调用的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>)pthread_kill(pthread_self(), SIGABRT);</span><br></pre></td></tr></table></figure>

<p>这里也可以看出，软件异常并不是转换为Mach再转换到Signal，而是直接转换为Signal的。</p>
<h4 id="EXC-CRASH"><a href="#EXC-CRASH" class="headerlink" title="EXC_CRASH"></a>EXC_CRASH</h4><p>为何以像<a target="_blank" rel="noopener" href="https://toutiao.io/posts/ziqho/preview">《漫谈 iOS Crash 收集框架》</a>这些文章会得出“首先沉下来被转换为Mach异常，再转换为Unix信号”这样的结论呢？我想大概是被 <code>EXC_CRASH</code> 所误导了。</p>
<p>系统通过launchd监听了EXC_CRASH。而 <code>EXC_CRASH</code> 是一种特殊类型，<strong>囊括硬件和软件异常</strong>，它什么都能抓。但是因为信号发出的时候，进程已经跪了，所以需要 out-of-process 处理。</p>
<p>看进程退出逻辑，EXC_CRASH 基本上会囊括所有的崩溃类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_prepareexit(proc_t p, <span class="keyword">int</span> rv, boolean_t perf_notify) </span><br><span class="line">&#123;</span><br><span class="line">	mach_exception_data_type_t code, subcode;</span><br><span class="line">	<span class="keyword">struct</span> uthread *ut;</span><br><span class="line">	thread_t <span class="keyword">self</span> = current_thread();</span><br><span class="line">	ut = get_bsdthread_info(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">/* If a core should be generated, notify crash reporter */</span></span><br><span class="line">	<span class="keyword">if</span> (hassigprop(WTERMSIG(rv), SA_CORE) || ((p-&gt;p_csflags &amp; CS_KILLED) != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/* </span></span><br><span class="line"><span class="comment">		 * Workaround for processes checking up on PT_DENY_ATTACH:</span></span><br><span class="line"><span class="comment">		 * should be backed out post-Leopard (details in 5431025).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((SIGSEGV == WTERMSIG(rv)) &amp;&amp; </span><br><span class="line">				(p-&gt;p_pptr-&gt;p_lflag &amp; P_LNOATTACH)) &#123;</span><br><span class="line">			<span class="keyword">goto</span> skipcheck;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Crash Reporter looks for the signal value, original exception</span></span><br><span class="line"><span class="comment">		 * type, and low 20 bits of the original code in code[0] </span></span><br><span class="line"><span class="comment">		 * (8, 4, and 20 bits respectively). code[1] is unmodified. </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		code = ((WTERMSIG(rv) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">			((ut-&gt;uu_exception &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">20</span>) | </span><br><span class="line">			((<span class="keyword">int</span>)ut-&gt;uu_code &amp; <span class="number">0xfffff</span>);</span><br><span class="line">		subcode = ut-&gt;uu_subcode;</span><br><span class="line">		(<span class="keyword">void</span>) task_exception_notify(EXC_CRASH, code, subcode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">skipcheck:</span><br><span class="line">	<span class="comment">/* Notify the perf server? */</span></span><br><span class="line">	<span class="keyword">if</span> (perf_notify) &#123;</span><br><span class="line">		(<span class="keyword">void</span>)sys_perf_notify(<span class="keyword">self</span>, p-&gt;p_pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Remove proc from allproc queue and from pidhash chain.</span></span><br><span class="line"><span class="comment">	 * Need to do this before we do anything that can block.</span></span><br><span class="line"><span class="comment">	 * Not doing causes things like mount() find this on allproc</span></span><br><span class="line"><span class="comment">	 * in partially cleaned state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	proc_list_lock();</span><br><span class="line"></span><br><span class="line">	LIST_REMOVE(p, p_list);</span><br><span class="line">	LIST_INSERT_HEAD(&amp;zombproc, p, p_list);	<span class="comment">/* Place onto zombproc. */</span></span><br><span class="line">	<span class="comment">/* will not be visible via proc_find */</span></span><br><span class="line">	p-&gt;p_listflag |= P_LIST_EXITED;</span><br><span class="line"></span><br><span class="line">	proc_list_unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PGINPROF</span></span><br><span class="line">	vmsizmon();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If parent is waiting for us to exit or exec,</span></span><br><span class="line"><span class="comment">	 * P_LPPWAIT is set; we will wakeup the parent below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	proc_lock(p);</span><br><span class="line">	p-&gt;p_lflag &amp;= ~(P_LTRACED | P_LPPWAIT);</span><br><span class="line">	p-&gt;p_sigignore = ~(sigcantmask);</span><br><span class="line">	ut-&gt;uu_siglist = <span class="number">0</span>;</span><br><span class="line">	proc_unlock(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在通知 Apple’s Crash Reporter 的时候，会把所有类型的的mach exception type都记为EXC_CRASH，自然也包括了SIGABRT</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception Type: EXC_CRASH (SIGABRT)</span><br><span class="line">Exception Codes: <span class="number">0x0000000000000000</span>, <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>所以，软/硬件异常最终都会转化为Signal信号，但他们的处理流程是<strong>不同的</strong>。</p>
<p>篇幅有限，这里不做过多介绍，感兴趣可以自行了解。</p>
<h4 id="Mach异常与Signal的选择"><a href="#Mach异常与Signal的选择" class="headerlink" title="Mach异常与Signal的选择"></a>Mach异常与Signal的选择</h4><h5 id="该捕获谁？"><a href="#该捕获谁？" class="headerlink" title="该捕获谁？"></a>该捕获谁？</h5><p>捕获Mach异常或者Signal都可以抓到Crash事件，这两种方式哪个更好呢？</p>
<p>理论上优选Mach异常，因为Mach异常处理会先于Signal处理发生，如果Mach异常的handler让程序exit了，那么Signal就永远不会到达这个进程了。</p>
<h5 id="为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？"><a href="#为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？" class="headerlink" title="为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？"></a>为何微软的著名框架PLCrashReporter会放弃捕捉Mach异常，而选择与之对应的SIGABRT信号？</h5><blockquote>
<p>We still need to use signal handlers to catch SIGABRT in-process. The kernel sends an EXC_CRASH mach exception to denote SIGABRT termination. In that case, catching the Mach exception in-process leads to process deadlock in an uninterruptable wait. Thus, we fall back on BSD signal handlers for SIGABRT, and do not register for EXC_CRASH.</p>
</blockquote>
<h3 id="Signal的捕获"><a href="#Signal的捕获" class="headerlink" title="Signal的捕获"></a>Signal的捕获</h3><p>从上面的结论可以看出，尽管Mach exception handle 比 UNIX signal handle 更有优势，但我们还是须要注册signal handle用于处理EXC_SOFTWARE/EXC_CRASH。</p>
<p>既然异常最终都会转换为Signal信号，那么我们可以将如何捕获<code>Mach Exception</code>的注意力转移到如何捕获<code>Signal</code>上了。</p>
<p>UNIX signals是一套基于<code>POSIX标准</code>开发的通信机制，POSIX API 就是通过 Mach 之上的 BSD 层实现的。</p>
<img src="/image/posix-bsd-mach.png" style="zoom:50%">

<p>在<code>signal.h</code>中声明了32种异常信号，以下六种为iOS常见的信号，它们均会导致程序崩溃。</p>
<table>
<thead>
<tr>
<th align="left">信号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIGILL</td>
<td align="left">执行了非法指令，一般是可执行文件出现了错误</td>
</tr>
<tr>
<td align="left">SIGTRAP</td>
<td align="left">断点指令或者其他trap指令产生</td>
</tr>
<tr>
<td align="left">SIGABRT</td>
<td align="left">调用abort产生</td>
</tr>
<tr>
<td align="left">SIGBUS</td>
<td align="left">非法地址。比如错误的内存类型访问、内存地址对齐等</td>
</tr>
<tr>
<td align="left">SIGSEGV</td>
<td align="left">非法地址。访问未分配内存、写入没有写权限的内存等</td>
</tr>
<tr>
<td align="left">SIGFPE</td>
<td align="left">致命的算术运算。比如数值溢出、NaN数值等</td>
</tr>
</tbody></table>
<p>Signal可以通过注册信号处理函数来捕获:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装有6种常见信号的信号数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// - Note: signalExceptionHandler 为捕获后的回调函数</span></span><br><span class="line">    signal([signals[index] intValue], &amp;SignalExceptionHandler);</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SignalExceptionHandler(<span class="keyword">int</span> signo) &#123;</span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Signal的调试"><a href="#Signal的调试" class="headerlink" title="Signal的调试"></a>Signal的调试</h4><h3 id="NSException异常的捕获"><a href="#NSException异常的捕获" class="headerlink" title="NSException异常的捕获"></a>NSException异常的捕获</h3><p><code>NSException</code>就属于我们前面所说的软件异常。它是应用级异常，发生在<code>CoreFoundation</code>以及更高抽象层级，会通过<code>__cxa_throw</code>函数抛出异常。如果没有人为进行捕获或者在捕获回调函数中没有进行操作终止应用，那么最终会通过<code>abort()</code>函数来向进程抛出一个<code>SIGABRT</code>的信号。</p>
<p><code>NSException</code>可以通过<code>@try-@catch</code>机制捕获，以此来避免应用Crash。同样地，如果没有catch处理，那么会被系统自带的错误处理所捕获，这个时候可以通过注册<code>NSUncaughtExceptionHandler</code>来捕获NSException异常。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册NSUncaughtExceptionHandler</span></span><br><span class="line"><span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃时的回调函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> * exception) &#123;</span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免覆盖"><a href="#避免覆盖" class="headerlink" title="避免覆盖"></a>避免覆盖</h4><p>如文章开头所提，我们的工程里可能已经包含一个或多个第三方的统计SDK，他们大多数都是基于<code>NSUncaughtExceptionHandler</code>进行崩溃收集。那么这个时候，一个不可避免的问题就产生了：由于<code>NSSetUncaughtExceptionHandler</code>函数存在覆盖现象，后注册的总会顶替掉前面注册的，当Crash发生时，永远只会触发最后注册传入的捕获回调函数。</p>
<p>而各家的SDK都会以保证自己的Crash统计正确完整为目的，难免出现强行覆盖等等的恶意竞争，就可能导致在其之前注册过的日志收集服务写出的Crash日志因为取不到NSException而丢失Last Exception Backtrace等重要信息。</p>
<p>所以正确的作法是：总是通过NSGetUncaughtExceptionHandler将之前别人注册的handler取出并备份（因为你可能并不清楚自己真正的注册顺序，所以最好每次都这么做），在自己handler处理完后记得把别人的handler注册回去，形成规范的SOP。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录之前的Crash回调函数（如果有的话）</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSUncaughtExceptionHandler</span> *previousUncaughtExceptionHandler = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)registerUncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="comment">// 将别人之前注册的Crash回调取出并备份</span></span><br><span class="line">    previousUncaughtExceptionHandler = <span class="built_in">NSGetUncaughtExceptionHandler</span>();</span><br><span class="line">    <span class="comment">// 然后再注册自己的</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃时的回调函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> * exception) &#123;</span><br><span class="line">    <span class="comment">// 异常的堆栈信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *stackInfo = [exception callStackSymbols];</span><br><span class="line">    <span class="comment">// 出现异常的原因</span></span><br><span class="line">    <span class="built_in">NSString</span> *reason = [exception reason];</span><br><span class="line">    <span class="comment">// 异常名称</span></span><br><span class="line">    <span class="built_in">NSString</span> *name = [exception name];</span><br><span class="line">    <span class="comment">// 异常错误报告</span></span><br><span class="line">    <span class="built_in">NSString</span> *exceptionInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;uncaughtException异常错误报告:\n name:%@\n reason:\n %@\n callStackSymbols:\n %@&quot;</span>, name, reason, [stackInfo componentsJoinedByString:<span class="string">@&quot;\n&quot;</span>]];</span><br><span class="line">    <span class="comment">// 保存Crash日志到沙盒cache目录</span></span><br><span class="line">    [<span class="built_in">SKTool</span> cacheCrashLog:exceptionInfo name:<span class="string">@&quot;CrashLog(UncaughtException)&quot;</span>];</span><br><span class="line">    <span class="comment">// 在自己handler处理完后记得把别人的handler注册回去，形成规范的SOP</span></span><br><span class="line">    <span class="keyword">if</span> (previousUncaughtExceptionHandler) &#123;</span><br><span class="line">        previousUncaughtExceptionHandler(exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 杀掉程序，这样可以防止同时抛出的SIGABRT被Signal异常捕获</span></span><br><span class="line">    kill(getpid(), SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关于断点调试"><a href="#关于断点调试" class="headerlink" title="关于断点调试"></a>关于断点调试</h3><h4 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h4><p>因为Xcode屏蔽了Signal的回调，我们需要在<code>lldb</code>中输入以下命令，Signal的回调才可以进来</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pro hand -p <span class="literal">true</span> -s <span class="literal">false</span> SIGABRT</span><br></pre></td></tr></table></figure>

<h4 id="NSSetUncaughtExceptionHandler"><a href="#NSSetUncaughtExceptionHandler" class="headerlink" title="NSSetUncaughtExceptionHandler"></a>NSSetUncaughtExceptionHandler</h4><p>在开发测试阶段，可以利用 <a target="_blank" rel="noopener" href="https://github.com/facebook/fishhook">fishhook</a> 框架去hook <code>NSSetUncaughtExceptionHandler</code>方法，这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。不推荐利用调试器添加符号断点来检查，原因是一些Crash收集框架或统计SDK在调试状态下是不工作的。</p>
<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>在调试阶段我们可能会看到许多crash callstack信息，下面列了几个常见的对应关系：</p>
<table>
<thead>
<tr>
<th align="left">地址</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0x8badf00d</td>
<td align="left">在启动、终止应用或响应系统事件花费过长时间，意思是”ate bad food”。</td>
</tr>
<tr>
<td align="left">0xdeadfa11</td>
<td align="left">用户强制退出,意为”dead fall”。(系统无响应时,用户按电源开关和HOME)</td>
</tr>
<tr>
<td align="left">0xbaaaaaad</td>
<td align="left">用户按住Home键和音量键，获取当前内存状态，不代表崩溃</td>
</tr>
<tr>
<td align="left">0xbad22222</td>
<td align="left">VoIP应用因为恢复得太频繁导致Crash</td>
</tr>
<tr>
<td align="left">0xc00010ff</td>
<td align="left">因为太烫了被干掉，意为”cool off”</td>
</tr>
<tr>
<td align="left">0xdead10cc</td>
<td align="left">因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为”dead lock”</td>
</tr>
</tbody></table>
<h3 id="线程保活提醒"><a href="#线程保活提醒" class="headerlink" title="线程保活提醒"></a>线程保活提醒</h3><p>按照我们之前所说，需要在崩溃现场或第一时间捕获崩溃信息，然后将崩溃堆栈信息及时反馈给我们的工程师。但是崩溃发生后，程序在完成回调后会立刻被杀死，在被杀死后无法进行任何后续操作，那么该怎么做呢？</p>
<h4 id="利用Runloop"><a href="#利用Runloop" class="headerlink" title="利用Runloop"></a>利用Runloop</h4><p>我们可以像这样创建一个<code>Runloop</code>，将主线程的所有<code>Runmode</code>都拿过来跑，作为应用程序主Runloop的替代。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFArrayRef</span> allModes = <span class="built_in">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class="line"><span class="keyword">while</span> (!dismissed) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)allModes) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CFRelease</span>(allModes);</span><br></pre></td></tr></table></figure>

<p>这样固然可以实现我们想要做的事情，但是会带来一个问题：因为我们为了继续执行程序而没有将控制权返回给导致崩溃的调用函数，并且我们启动了自己的<code>Runloop</code>，所以永远不会返回到原始的<code>Runloop</code>中去了，这将意味着导致异常的线程使用的<code>堆栈内存</code>将永久泄漏。因此这种类型的方法应被视为调试工具或最后手段，所以，不要在Debug以外的环境使用它。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> InstallUncaughtExceptionHandler(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="comment">// 注册 NSException</span></span><br><span class="line">	<span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;HandleException); </span><br><span class="line"> 	<span class="comment">// 注册 Signal</span></span><br><span class="line"> 	<span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    	signal([signals[index] intValue], &amp;SignalExceptionHandler);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HandleException(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="comment">// OSAtomicIncrement32是一个递增的一个全局计数器，既快速又安全，是为了防止并发数太大出现错误的情况。</span></span><br><span class="line">    int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);</span><br><span class="line">    <span class="keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 获取堆栈信息的数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *callStack = [<span class="built_in">SKUncaughtExceptionHandler</span> backtrace];</span><br><span class="line">    <span class="comment">// 设置该字典</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *userInfo =</span><br><span class="line">    [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:[exception userInfo]];</span><br><span class="line">    <span class="comment">// 给堆栈信息设置地址Key</span></span><br><span class="line">    [userInfo</span><br><span class="line">     setObject:callStack</span><br><span class="line">     forKey:UncaughtExceptionHandlerAddressesKey];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 假如崩溃了执行 handleException: ，并且传出 NSException</span></span><br><span class="line">    [[[<span class="built_in">SKUncaughtExceptionHandler</span> alloc] init] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:[<span class="built_in">NSException</span> exceptionWithName:[exception name] reason:[exception reason]</span><br><span class="line">      userInfo:userInfo]</span><br><span class="line">     waitUntilDone:<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SignalExceptionHandler(<span class="keyword">int</span> signal) &#123;</span><br><span class="line">    <span class="comment">// 全局计数器</span></span><br><span class="line">    int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);</span><br><span class="line">    <span class="keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录Signal</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *userInfo =</span><br><span class="line">    [<span class="built_in">NSMutableDictionary</span></span><br><span class="line">     dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithInt:signal]</span><br><span class="line">     forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class="line">    <span class="comment">// 获取堆栈信息数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *callStack = [UncaughtExceptionHandler backtrace];</span><br><span class="line">    <span class="comment">// 写入地址</span></span><br><span class="line">    [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];</span><br><span class="line">    <span class="comment">// 假如崩溃了执行 handleException: ，并且传出 NSException</span></span><br><span class="line">    [[[<span class="built_in">SKUncaughtExceptionHandler</span> alloc] init] performSelectorOnMainThread:<span class="keyword">@selector</span>(handleException:) withObject:[<span class="built_in">NSException</span> exceptionWithName:UncaughtExceptionHandlerSignalExceptionName reason: [<span class="built_in">NSString</span> stringWithFormat:</span><br><span class="line">       <span class="built_in">NSLocalizedString</span>(<span class="string">@&quot;Signal %d was raised.&quot;</span>, <span class="literal">nil</span>),signal] userInfo:[<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey]] waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)backtrace &#123;</span><br><span class="line">    <span class="keyword">void</span>* callstack[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">//  该函数用来获取当前线程调用堆栈的信息,获取的信息将会被存放在buffer中(callstack),它是一个指针数组。</span></span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">//  backtrace_symbols将从backtrace函数获取的信息转化为一个字符串数组.</span></span><br><span class="line">    <span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">         <span class="keyword">int</span> i = UncaughtExceptionHandlerSkipAddressCount;</span><br><span class="line">         i &lt; UncaughtExceptionHandlerSkipAddressCount + UncaughtExceptionHandlerReportAddressCount;</span><br><span class="line">         i++)</span><br><span class="line">    &#123;</span><br><span class="line">        [backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs); <span class="comment">// 记得释放</span></span><br><span class="line">    <span class="keyword">return</span> backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleException:(<span class="built_in">NSException</span> *)exception &#123;</span><br><span class="line">    <span class="comment">// 打印或弹出框</span></span><br><span class="line">		<span class="comment">// 此处省略</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建自己的Runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFArrayRef</span> allModes = <span class="built_in">CFRunLoopCopyAllModes</span>(runLoop);</span><br><span class="line">    <span class="keyword">while</span> (!dismissed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *mode <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)allModes) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>((<span class="built_in">CFStringRef</span>)mode, <span class="number">0.001</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(allModes);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注销NSException和Signal</span></span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">NSArray</span> *signals = @[@(SIGABRT), @(SIGBUS), @(SIGFPE), @(SIGILL), @(SIGTRAP), @(SIGSEGV)];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; signals.count; index ++) &#123;</span><br><span class="line">    	signal([signals[index] intValue], SIG_DFL);</span><br><span class="line">	&#125;&#125;</span><br><span class="line">    <span class="comment">// 杀死 或 唤起</span></span><br><span class="line">    <span class="keyword">if</span> ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName]) &#123;</span><br><span class="line">        kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [exception raise];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Crash-定位"><a href="#Crash-定位" class="headerlink" title="Crash 定位"></a>Crash 定位</h3><p>前面我们已经将Crash的上报工作做完了，也就是解决了第一个问题: <strong>发现问题</strong>。问题既然被发现，那么就必须要被解决，一个Crash如何保证得到处理，需要准确地对Crash行为进行复现，也就是回到案发现场，场景再现。</p>
<p>有些Crash比较容易复现，比如UI操作类、数组越界等，只要定位到具体的类，很快就能复现出崩溃，这种问题就比较好解决，我们称之为<strong>可稳定复现</strong>。既然有可以稳定复现的Crash，相对的也存在不那么稳定复现的Crash，它需要特定的条件才得以触发。比如同样的数据，在32位机器下的某个操作场景下就会Crash，而在64位机器下就无事发生，像这种问题我们就称为<strong>不稳定复现</strong>。</p>
<p>像上述提到的两种问题，还都属于<strong>可复现</strong>的范畴内，通过排查各种客观因素，还是有很大概率能够复现出来的，这些都算不上定位上的难点。而真正难以复现的问题，往往是使用者无法直接感知到原因的，它可能在A页面发生闪退，重启后A没事了缺又在B页面闪退，令人头疼不已。这类问题往往都发生在内存上，最臭名昭著的就是<strong>野指针</strong>，像这种<strong>极难复现</strong>的问题，它需要工程师花费大量的时间和精力去排查，着手分析，不仅解决效率极低，且难以稳定暴露，最痛苦的是它往往就是你CrashList里出现频率最高的问题，那么有没有办法可以治它呢，答案是：有。</p>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><blockquote>
<p><strong>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称野指针。</strong></p>
</blockquote>
<p>为什么线上的野指针问题层出不穷，我们在测试阶段都干嘛了？按理说测试阶段该跑的case都跑了，如果有问题早就有了，为什么就没有被发现呢？这个问题还真问题对了，它往往就是没有在测试阶段被发现，它的出现有太多的不确定性，不是依靠简单的提高测试覆盖率就能解决的。即使你跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致Crash</p>
<h5 id="为什么不必现"><a href="#为什么不必现" class="headerlink" title="为什么不必现"></a>为什么不必现</h5><p>野指针是指，指向一个<code>已删除</code>的对象或未申请<code>访问受限</code>的内存的指针。我们这里主要说的是objc对象释放后指针未置空所导致的野指针。</p>
<p>既然是访问已经释放的对象为什么不是必现呢？</p>
<p>这是 iOS 内存管理方式所造成的，当析构执行（dealloc）后，只是告诉系统，这片内存我不用了，而系统并没有就让这片内存真的不能访问。</p>
<p>比如说下面这几种场景</p>
<ul>
<li><p>对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。</p>
</li>
<li><p>对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。</p>
</li>
<li><p>对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）。</p>
</li>
<li><p>对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。</p>
</li>
</ul>
<h5 id="野指针定位"><a href="#野指针定位" class="headerlink" title="野指针定位"></a>野指针定位</h5><p>目前有两种主要的方法来进行野指针定位</p>
<ul>
<li>通过<code>free函数</code>来进行野指针定位</li>
<li>通过<code>dealloc</code>函数来进行野指针定位</li>
</ul>
<h6 id="通过free函数"><a href="#通过free函数" class="headerlink" title="通过free函数"></a>通过free函数</h6><p>通过<code>fishhook</code>替换<code>C函数</code>的<code>free</code>方法为自身方法<code>safe_free</code>，就类似<code>runtime</code>的`方法交换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> init_safe_free() &#123;</span><br><span class="line">    _unfreeQueue = ds_queue_create(MAX_STEAL_MEM_NUM);</span><br><span class="line">    orig_free = (<span class="keyword">void</span>(*)(<span class="keyword">void</span>*))dlsym(RTLD_DEFAULT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    rebind_symbols((<span class="keyword">struct</span> rebinding[])&#123;&#123;<span class="string">&quot;free&quot;</span>, (<span class="keyword">void</span>*)safe_free&#125;&#125;, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>safe_free</code>方法中对<code>已经释放变量</code>的内存，填充<code>0x55</code>，使已经释放变量不能访问，从而使某些野指针从不必现Crash变成了必现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> safe_free(<span class="keyword">void</span> *p) &#123;</span><br><span class="line">    size_tmemSiziee = malloc_size(p);</span><br><span class="line">    memset(p,<span class="number">0x55</span>, memSiziee);</span><br><span class="line">    orig_free(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里之所以填充为<code>0x55</code>是因为Xcode的僵尸对象（ Zombie Object）填充的就是<code>0x55</code>。<br> 如果填充为像<code>0x22</code>这样的数据也是可以，因为之前这里是存储的是一个对象，这个对象被数据覆盖了，当你调用方法的时候，数据无法响应<code>对应的方法</code>，因此也会导致崩溃。</p>
<p>但是由于填充了0x55的内存地址很可能被新的数据内容填充，使得野指针的crash又变得不必现。</p>
<p>例如下面这种情况:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *testObj = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="comment">// 这里的testObj指向的内存空间的内容被填充为0x55，然后调用free真正释放了，这块内存空间被系统回收利用，但testObj仍然指向这块内存空间</span></span><br><span class="line">[testObj release];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 紧接着新生成的UIView很快的就会覆盖了testObj指向的内存空间，这时候testObj指向的仍然还是一个UIView对象</span></span><br><span class="line">  <span class="built_in">UIView</span>* testView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">200</span>,<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.view.bounds), <span class="number">60</span>)];</span><br><span class="line">  [<span class="keyword">self</span>.view addSubview:testView];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时候调用UIView的实例方法setNeedsLayout方法完全不会发生Crash</span></span><br><span class="line">[testObj setNeedsLayout];</span><br></pre></td></tr></table></figure>

<p>没有发生Crash可不是好事，因为这种情况如果后续再Crash，问题就非常难查，因为你看到的Crash栈很可能和出错的代码完全没有关联。既然这个问题这么棘手，最好还是和之前一样，让这个Crash提前暴露。</p>
<p>为了防止上面这种情况，我们干脆就不释放这片内存了。也就是当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> DSQueue* _unfreeQueue = <span class="literal">NULL</span>;<span class="comment">//用来保存自己偷偷保留的内存:1这个队列要线程安全或者自己加锁;2这个队列内部应该尽量少申请和释放堆内存。</span></span><br><span class="line"><span class="keyword">int</span> unfreeSize = <span class="number">0</span>;<span class="comment">//用来记录我们偷偷保存的内存的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STEAL_MEM_SIZE 1024*1024*100<span class="comment">//最多存这么多内存，大于这个值就释放一部分</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_STEAL_MEM_NUM 1024*1024*10<span class="comment">//最多保留这么多个指针，再多就释放一部分</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BATCH_FREE_NUM 100<span class="comment">//每次释放的时候释放指针数量</span></span></span><br></pre></td></tr></table></figure>

<p>为了防止系统内存过快耗尽,我们需要在自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。同时在系统内存警告的时候，也要释放一部分内存。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统内存警告的时候调用这个函数释放一些内存</span></span><br><span class="line"><span class="keyword">void</span> free_some_mem(size_t freeNum)&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    size_t count = ds_queue_length(_unfreeQueue);</span><br><span class="line">    freeNum= freeNum &gt; count ? count:freeNum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;freeNum; i++) &#123;</span><br><span class="line">        <span class="keyword">void</span> *unfreePoint = ds_queue_get(_unfreeQueue);</span><br><span class="line">        size_t memSiziee = malloc_size(unfreePoint);</span><br><span class="line">        __sync_fetch_and_sub(&amp;unfreeSize, memSiziee);</span><br><span class="line">        orig_free(unfreePoint);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果只是对已经释放的对象内存空间填充为0x55,这样发生Crash的时候，我们得到的崩溃信息非常有限，但对于崩溃信息，我们肯定希望知道更具体一点:比如是哪个类，调了什么方法，对象的地址之类。</p>
<p>为了解决上述的问题，我们需要引入一个继承自NSProxy的代理类，同时它持有一个originClass，重写消息转发的三个方法以及NSObject的实例方法，来进行异常信息的打印。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector: (SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.originClass instancesRespondToSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector: (SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.originClass instanceMethodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation: (<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> _throwMessageSentExceptionWithSelector: invocation.selector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)_throwMessageSentExceptionWithSelector: (SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInternalInconsistencyException</span> reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;(-[%@ %@]) was sent to a zombie object at address: %p&quot;</span>, <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.originClass), <span class="built_in">NSStringFromSelector</span>(selector), <span class="keyword">self</span>] userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为NSProxy只能作为Objc对象的代理，所以safe_free函数需要添加判断。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> safe_free(<span class="keyword">void</span>* p)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> unFreeCount = ds_queue_length(_unfreeQueue);</span><br><span class="line">    <span class="comment">// 保留的内存大于一定值的时候就释放一部分</span></span><br><span class="line">    <span class="keyword">if</span> (unFreeCount &gt; MAX_STEAL_MEM_NUM*<span class="number">0.9</span> || unfreeSize&gt;MAX_STEAL_MEM_SIZE) &#123;</span><br><span class="line">        free_some_mem(BATCH_FREE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        size_t memSiziee = malloc_size(p);</span><br><span class="line">        <span class="keyword">if</span> (memSiziee &gt; sYHCatchSize) &#123;<span class="comment">//有足够的空间才覆盖</span></span><br><span class="line">            <span class="keyword">id</span> obj=(<span class="keyword">id</span>)p;</span><br><span class="line">            Class origClass= object_getClass(obj);</span><br><span class="line">            <span class="comment">// 判断是不是objc对象</span></span><br><span class="line">            <span class="keyword">char</span> *type = <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(obj));</span><br><span class="line">            <span class="keyword">if</span> (strcmp(<span class="string">&quot;@&quot;</span>, type) == <span class="number">0</span>) &#123;</span><br><span class="line">                memset(obj, <span class="number">0x55</span>, memSiziee);</span><br><span class="line">                memcpy(obj, &amp;sYHCatchIsa, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));<span class="comment">//把我们自己的类的isa复制过去</span></span><br><span class="line">                </span><br><span class="line">                object_setClass(obj, [MOACatcher <span class="keyword">class</span>]);</span><br><span class="line">                ((MOACatcher *)obj).originClass = origClass;</span><br><span class="line">                __sync_fetch_and_add(&amp;unfreeSize,(<span class="keyword">int</span>)memSiziee);<span class="comment">//多线程下int的原子加操作,多线程对全局变量进行自加，不用理线程锁了</span></span><br><span class="line">                ds_queue_put(_unfreeQueue, p);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               orig_free(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           orig_free(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="通过dealloc函数"><a href="#通过dealloc函数" class="headerlink" title="通过dealloc函数"></a>通过dealloc函数</h6><p>通过objc的runtime方法进行方法交换，交换了根类的NSObject和NSProxy的dealloc方法为originalDeallocImp。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *deallocImps = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">for</span> (Class rootClass <span class="keyword">in</span> _rootClasses) &#123;</span><br><span class="line">    IMP originalDeallocImp = __lxd_swizzleMethodWithBlock(class_getInstanceMethod(rootClass, <span class="keyword">@selector</span>(dealloc)), swizzledDeallocBlock);</span><br><span class="line">    [deallocImps setObject: [<span class="built_in">NSValue</span> valueWithBytes: &amp;originalDeallocImp objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(IMP))] forKey: <span class="built_in">NSStringFromClass</span>(rootClass)];</span><br><span class="line">&#125;</span><br><span class="line">_rootClassDeallocImps = [deallocImps <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure>

<p>为了避免 内存空间释放之后被复写造成野指针问题，通过字典_rootClassDeallocImps存储被释放的对象，同时设置在30秒之后调用dealloc方法将存储的对象释放，避免内存空间的增大。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      swizzledDeallocBlock = [^<span class="keyword">void</span>(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">          Class currentClass = [obj <span class="keyword">class</span>];</span><br><span class="line">          <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(currentClass);</span><br><span class="line">          <span class="keyword">if</span> ([__lxd_sniff_white_list() containsObject: clsName]) &#123;</span><br><span class="line">              __lxd_dealloc(obj);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">NSValue</span> *objVal = [<span class="built_in">NSValue</span> valueWithBytes: &amp;obj objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(obj))];</span><br><span class="line">              object_setClass(obj, [LXDZombieProxy <span class="keyword">class</span>]);</span><br><span class="line">              ((LXDZombieProxy *)obj).originClass = currentClass;</span><br><span class="line"></span><br><span class="line">              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">30</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                  __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> deallocObj = <span class="literal">nil</span>;</span><br><span class="line">                  [objVal getValue: &amp;deallocObj];</span><br><span class="line">                  object_setClass(deallocObj, currentClass);</span><br><span class="line">                  __lxd_dealloc(deallocObj);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">copy</span>];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>也同样为了获取更多的崩溃信息采用了继承自NSProxy类的代理类的来进行消息转发，重写消息转发方法以及内存管理相关的方法。</p>
<p>因为objc内部还有一些底层的类，这些类我们项目中一般不涉及，因此不会是这些类造成野指针，就可以通过白名单的机制，放弃对这些类的dealloc方法的捕获。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSMutableSet</span> *__lxd_sniff_white_list() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *lxd_sniff_white_list;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        lxd_sniff_white_list = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> lxd_sniff_white_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>free函数</code>来进行野指针定位</p>
<ul>
<li><strong>优点:</strong> 覆盖范围广，覆盖了objc、C++、C函数，对于iOS项目适用于混编的工程。</li>
<li><strong>缺点:</strong> 想要获得具体的<code>崩溃信息</code>，还是需要进行objc对象的判断，同时<code>free函数</code>的覆盖范围广，也会造成一定性能的损耗，毕竟我们在<code>safe_free</code>中添加了一些判断。</li>
</ul>
<p>通过<code>dealloc</code>函数来进行<code>野指针</code>定位</p>
<ul>
<li><strong>优点:</strong> 针对objc语言，利用objc的<code>方法交换</code>、<code>消息转发</code>等特性，对于iOS 项目来说更具有<code>针对性</code>和<code>可扩展性</code>。</li>
<li><strong>缺点:</strong> 相对作用范围较小</li>
</ul>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/interview-dispatch-once/" title="dispatch_once 为什么可以保证只执行一次？">dispatch_once 为什么可以保证只执行一次？</a></h2>
                <p class="excerpt">
                
                想尝试写一个面试回答的系列，这是第一篇。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-05-08T06:12:02.000Z" class="post-list__meta--date date">2020-05-08</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/GCD/" rel="tag">GCD</a>, <a class="-none-link" href="/tags/dispatch-once/" rel="tag">dispatch_once</a>, <a class="-none-link" href="/tags/iOS/" rel="tag">iOS</a>
</span><a class="btn-border-small" href="/interview-dispatch-once/">开始阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/use-navicat-premium-for-mac/" title="Navicat Premium For Mac 备份与恢复数据库">Navicat Premium For Mac 备份与恢复数据库</a></h2>
                <p class="excerpt">
                
                在 macOS 系统上使用 Navicat Premium 对服务器上的数据库进行本地备份，以及数据库丢失后的恢复。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2020-01-10T06:59:03.000Z" class="post-list__meta--date date">2020-01-10</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="-none-link" href="/tags/MariaDB/" rel="tag">MariaDB</a>, <a class="-none-link" href="/tags/MySQL/" rel="tag">MySQL</a>, <a class="-none-link" href="/tags/NavicatPremium/" rel="tag">NavicatPremium</a>, <a class="-none-link" href="/tags/%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B0/" rel="tag">折腾日记</a>, <a class="-none-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD/" rel="tag">数据库备份</a>
</span><a class="btn-border-small" href="/use-navicat-premium-for-mac/">开始阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  
<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'warpdrive'; 
      
  var disqus_identifier = '/ios-crashprotection/';
  var disqus_title = '浅谈 iOS 中的 Crash 捕获与防护';
  var disqus_url = 'http://shevakuilin.com/ios-crashprotection/';
  

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          //dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
          dsq.src = 'https://a.disquscdn.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a target="_blank" rel="noopener" href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2020 ShevaKuilin - 跃迁引擎 <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"> 渝ICP备 19012091</a>, 本站点采用 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a> 搭建，使用 <a target="_blank" rel="noopener" href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a target="_blank" rel="noopener" href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
    


    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
